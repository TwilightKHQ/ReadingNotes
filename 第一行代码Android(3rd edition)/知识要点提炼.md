# 第一行代码Android(第3版)

## 第5章 手机平板要兼顾，探究Fragment

1. 建议：向哪个类添加扩展函数就定义一个同名的Kotlin文件
2. 将扩展函数定义成顶层方法，可以让扩展函数有全局的访问域
3. 语法糖: 运算符重载(需要指定函数)

```kotlin
class Obj {
	operator fun plus(obj: Obj): Obj {
		// 处理逻辑		
	}
}
```

关键字 `operator` 和函数名 `plus` 是固定不变的，接收的参数和返回的值可以自定义

可以对同一个运算符进行多重重载

```kotlin
class Money(val value: Int) {

    operator fun plus(money: Money): Money {
        val sum = value + money.value
        return Money(sum)
    }

    operator fun plus(newValue: Int): Money {
        val sum = value + newValue
        return Money(sum)
    }
}
```

4. 语法糖表达式和实际调用函数对照表

一元前缀操作符

| 表达式 | 实际调用函数     |
| :----- | :--------------- |
| `+a`   | `a.unaryPlus()`  |
| `-a`   | `a.unaryMinus()` |
| `!a`   | `a.not()`        |

递增与递减

| 表达式 | 实际调用函数       |
| :----- | :----------------- |
| `a++`  | `a.inc()` + 见下文 |
| `a--`  | `a.dec()` + 见下文 |

算术运算符

| 表达式  | 实际调用函数   |
| :------ | :------------- |
| `a + b` | `a.plus(b)`    |
| `a - b` | `a.minus(b)`   |
| `a * b` | `a.times(b)`   |
| `a / b` | `a.div(b)`     |
| `a % b` | `a.rem(b)`     |
| `a..b`  | `a.rangeTo(b)` |

“In”操作符

| 表达式    | 实际调用函数     |
| :-------- | :--------------- |
| `a in b`  | `b.contains(a)`  |
| `a !in b` | `!b.contains(a)` |

索引访问操作符

| 表达式                | 实际调用函数             |
| :-------------------- | :----------------------- |
| `a[i]`                | `a.get(i)`               |
| `a[i, j]`             | `a.get(i, j)`            |
| `a[i_1, ……, i_n]`     | `a.get(i_1, ……, i_n)`    |
| `a[i] = b`            | `a.set(i, b)`            |
| `a[i, j] = b`         | `a.set(i, j, b)`         |
| `a[i_1, ……, i_n] = b` | `a.set(i_1, ……, i_n, b)` |

调用操作符

| 表达式            | 实际调用函数             |
| :---------------- | :----------------------- |
| `a()`             | `a.invoke()`             |
| `a(i)`            | `a.invoke(i)`            |
| `a(i, j)`         | `a.invoke(i, j)`         |
| `a(i_1, ……, i_n)` | `a.invoke(i_1, ……, i_n)` |

广义赋值

| 表达式   | 实际调用函数       |
| :------- | :----------------- |
| `a += b` | `a.plusAssign(b)`  |
| `a -= b` | `a.minusAssign(b)` |
| `a *= b` | `a.timesAssign(b)` |
| `a /= b` | `a.divAssign(b)`   |
| `a %= b` | `a.remAssign(b)`   |

相等与不等操作符

| 表达式   | 实际调用函数                      |
| :------- | :-------------------------------- |
| `a == b` | `a?.equals(b) ?: (b === null)`    |
| `a != b` | `!(a?.equals(b) ?: (b === null))` |

比较操作符

| 表达式   | 实际调用函数          |
| :------- | :-------------------- |
| `a > b`  | `a.compareTo(b) > 0`  |
| `a < b`  | `a.compareTo(b) < 0`  |
| `a >= b` | `a.compareTo(b) >= 0` |
| `a <= b` | `a.compareTo(b) <= 0` |

## 第6章 全局大喇叭，详解广播机制

#### 6.1 广播机制简介

标准广播：异步执行 所有BroadcastReceiver几乎同时收到广播 无法拦截

有序广播：同步执行 上一级处理完后才到下一级处理 可以拦截

#### 6.2 接收系统广播

静态注册：XML注册 开机有效 隐式广播不可(8.0后)

动态注册：代码注册 注册有效 手动注销 

完整系统广播列表：

```
<Android SDK>/platforms/<Android Api版本>/data/broadcast_actions.txt
```

***注意*** ：

不要在广播的onReceive( )方法中进行耗时操作，广播是运行在主线程，长时间未响应会导致ANR。

同时在BroadcastReceiver中创建子线程进行操作是不可靠的，其所在进程可能会被杀死

#### 6.3 发送自定义广播

```kotlin
// 发送广播时 指定接收广播的包名
// 否则静态广播无法接收到
intent.setPackage(packageName)
```

```kotlin
// 有序广播通过设置 priority 设置广播接收优先级
abortBroadcast() // 拦截广播
```

#### 6.4 广播最佳实践

在BaseActivity中注册强制下线的广播，不需要在每个Activity都添加接收到强制下线广播弹窗的逻辑

在onResume( )和onPause( )中注册和注销广播可以保证只有栈顶的Activity才能接收到广播

#### 6.5 Kotlin课堂：高阶函数详解

定义高阶函数

函数类型：以传入参数的类型以及返回值类型为分类标准

将函数类型当做参数或者返回值的就是高阶函数

函数类型可以定义到指定类当中，调用高阶函数时，传入的函数自动拥有指定类的上下文

```kotlin
fun StringBuilder.build(block: StringBuilder.() -> Unit): StringBuilder {
    block()
    return this
}
val list = listOf("Apple", "Banana", "Orange", "Pear", "Grape")
val result = StringBuilder().build {
    append("Start eating fruits.\n")
    for (fruit in list) {
        append(fruit).append("\n")
    }
    append("Ate all fruits.")
}
println(result.toString())
// 	  输出结果
//    Start eating fruits.
//    Apple
//    Banana
//    Orange
//    Pear
//    Grape
//    Ate all fruits.
```

内联函数

`inline` 

Kotlin编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方， 减少额外的内存和性能开销

`noinline`

`inline` 会进行函数返回，`noinline` 只能进行局部返回

`crossinline`

禁用 `inline` 函数当中的 `return` ，但是可以继续使用局部返回



## 第7章 数据存储全方案，详细持久化技术

#### 7.1 持久化技术简介

文件存储、SharedPreferences存储以及数据库存储

#### 7.2 文件存储

文件存储： 不对存储数据进行处理  	适合存储简单的文本数据或者二进制数据

###### 写

```kotlin
private fun save(inputText: String) {
    try {
        // 第一个参数为文件名，默认路径为/data/data/<package name>/files/
        // 第二个参数为模式， MODE_PRIVATE 覆盖原文件 MODE_APPEND 追加内容
        val output = openFileOutput("data", Context.MODE_PRIVATE)
        val writer = BufferedWriter(OutputStreamWriter(output))
        // use 内置扩展函数 Lambda表达式内的代码执行完后自动关闭外层的流
        writer.use {
            it.write(inputText)
        }
    } catch (e: IOException) {
        e.printStackTrace()
    }
}
```

###### 读

```kotlin
private fun load(): String {
    val content = StringBuilder()
    try {
        // 参数为文件名，默认路径为/data/data/<package name>/files/
        val input = openFileInput("data")
        val reader = BufferedReader(InputStreamReader(input))
        reader.use {
            // forEachLine 内置扩展函数 将读取到的每行内容回调至Lambda表达式中
            reader.forEachLine {
                content.append(it)
            }
        }
    } catch (e: IOException) {
        e.printStackTrace()
    }
    return content.toString()
}
```

#### 7.3 SharedPreferences存储

SharedPreferences存储： 键值对存储 	根据数据类型存储 	XML格式存储

###### 存

```kotlin
// Context类中的 getSharedPreferences()方法
// 第一个参数指定文件名 默认路径为/data/data/<package name>/shared_prefs/
// 第二个参数指定模式 MODE_PRIVATE 表示只有当前应用可读写
// Activity类中的 getSharedPreferences()方法
// 只接受指定模式参数 名称默认使用当前Activity的类名
val editor = getSharedPreferences("data", Context.MODE_PRIVATE).edit()
// Key-Value
editor.putString("name", "Tom")
editor.putInt("age", 28)
editor.putBoolean("married", false)
editor.apply()
```

###### 取

```kotlin
val prefs = getSharedPreferences("data", Context.MODE_PRIVATE)
// Key - Default
val name = prefs.getString("name", "")
val age = prefs.getInt("age", 0)
val married = prefs.getBoolean("married", false)
```

#### 7.4 SQLite数据库存储

SQLite数据库存储： 适合存储数据量较大、结构较复杂的数据 	数据库格式存储

###### 创

```kotlin
// context 上下文
// name 数据库名称
// null 自定义Cursor
// version 数据库版本号 version >= 1
// 数据库文件默认路径：/data/data/<package name>/databases/
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    // 数据库库类型 integer 整型 real 浮点型 text 文本类型 blob 二进制类型
    // primary key 主键 autoincrement 自增长。
    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }
}

val dbHelper = MyDatabaseHelper(this, "BookStore.db", 1)
// 当表不存在时创建表，表存在则获取表
dbHelper.writableDatabase
```

###### 升

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    private val createCategory = "create table Category (" +
            "id integer primary key autoincrement," +
            "category_name text," +
            "category_code integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }
	// newVersion > oldVersion 时执行
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 如果表存在则删除
        db.execSQL("drop table if exists Book")
        db.execSQL("drop table if exists Category")
        onCreate(db)
    }
}

val dbHelper = MyDatabaseHelper(this, "BookStore.db", 2)
dbHelper.writableDatabase
```

###### 增

```kotlin
val db = dbHelper.writableDatabase
val values1 = ContentValues().apply {
    // 开始组装第一条数据
    put("name", "The Da Vinci Code")
    put("author", "Dan Brown")
    put("pages", 454)
    put("price", 16.96)
}
// insert(String table, String nullColumnHack, ContentValues values)
// table 表名
// nullColumnHack 在未指定添加数据时为指定空列赋值NULL， 一般填null
// values ContentValues对象
db.insert("Book", null, values1) // 插入第一条数据
val values2 = ContentValues().apply {
    // 开始组装第二条数据
    put("name", "The Lost Symbol")
    put("author", "Dan Brown")
    put("pages", 510)
    put("price", 19.95)
}
db.insert("Book", null, values2) // 插入第二条数据
```

###### 改

```kotlin
val db = dbHelper.writableDatabase
val values = ContentValues()
values.put("price", 10.99)
// update(String table, ContentValues values, String whereClause, String[] whereArgs)
// table 表名
// values ContentValues对象
// whereClause 更新指定参数的行
// whereArgs 指定的参数
val rows = db.update("Book", values, "name = ?", arrayOf("The Da Vinci Code"))
```

###### 删

```kotlin
val db = dbHelper.writableDatabase
// delete(String table, String whereClause, String[] whereArgs)
// table 表名
// whereClause 指定参数的行
// whereArgs 指定的参数
db.delete("Book", "pages > ?", arrayOf("500"))
```

###### 查

```kotlin
query(String table, String[] columns, String selection,
      String[] selectionArgs, String groupBy, String having,
      String orderBy)
```

| query方法参数 | 对应SQL的部分             | 描述                          |
| ------------- | ------------------------- | ----------------------------- |
| table         | from table_name           | 指定查询的表名                |
| columns       | select column1, column2   | 指定查询的列名                |
| selection     | where column = value      | 指定where的约束条件           |
| selectionArgs | -                         | 为where中的占位符提供具体的值 |
| groupBy       | group by column           | 指定需要的group by的列        |
| having        | having column = value     | 对group by后的结果进一步约束  |
| orderBy       | order by column1, column2 | 指定查询结果的排序方式        |

```kotlin
val db = dbHelper.writableDatabase
// 查询Book表中所有的数据
val cursor = db.query("Book", null, null, null, null, null, null)
if (cursor.moveToFirst()) {
    do {
        // 遍历Cursor对象，取出数据并打印
        val name = cursor.getString(cursor.getColumnIndex("name"))
        val author = cursor.getString(cursor.getColumnIndex("author"))
        val pages = cursor.getInt(cursor.getColumnIndex("pages"))
        val price = cursor.getDouble(cursor.getColumnIndex("price"))
        Log.d("MainActivity", "book name is $name")
        Log.d("MainActivity", "book author is $author")
        Log.d("MainActivity", "book pages is $pages")
        Log.d("MainActivity", "book price is $price")
    } while (cursor.moveToNext())
}
cursor.close()
```

###### 使用SQL操作数据库

添加数据：

```kotlin
db.execSQL(
    "insert into Book (name, author, pages, price) values(?, ?, ?, ?)",
    arrayOf("The Da Vinci Code", "Dan Brown", "454", "16.96")
)
```

更新数据：

```kotlin
db.execSQL(
    "update Book set price = ? where name = ?",
    arrayOf("10.99", "The Da Vinci Code")
)
```

删除数据：

```kotlin
db.execSQL("delete from Book where paged > ?", arrayOf("500"))
```

查询数据：

```kotlin
val cursor = db.rawQuery("select * from Book", null)
```

#### 7.5 SQLite数据库的最佳实践

事务：保证一系列的操作要么全部成功，要么一个都不会完成。

```kotlin
val db = dbHelper.writableDatabase
db.beginTransaction() // 开启事务
try {
    db.delete("Book", null, null)
    if (true) {
        // 在这里手动抛出一个异常，让事务失败
        throw NullPointerException()
    }
    val values = cvOf(
        "name" to "Game of Thrones",
        "author" to "George Martin",
        "pages" to 720,
        "price" to 20.85
    )
    db.insert("Book", null, values)
    db.setTransactionSuccessful() // 事务已经执行成功
} catch (e: Exception) {
    e.printStackTrace()
} finally {
    db.endTransaction() // 结束事务
}
```

数据库版本更新：

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    private val createCategory = "create table Category (" +
            "id integer primary key autoincrement," +
            "category_name text," +
            "category_code integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 新增一张表
        if (oldVersion <= 1) {
            db.execSQL(createCategory)
        }
        // 原有表新增列
        if (oldVersion <= 2) {
            db.execSQL("alter table Book add column category_id integer")
        }
    }
}
```

#### 7.6 Kotlin课堂：高阶函数的应用

###### 例1： SharedPreferences使用简化

```kotlin
// open函数内拥有SharedPreferences.Editor的上下文
fun SharedPreferences.edit(block: SharedPreferences.Editor.() -> Unit) {
    val editor = edit()
    editor.block()
    editor.apply()
}
```

7.3中的存可以简化成以下代码：

```kotlin
getSharedPreferences("data", Context.MODE_PRIVATE).edit {
    putString("name", "Tom")
    putInt("age", 28)
    putBoolean("married", false)
}
```

###### 例2： ContentValues使用简化

```kotlin
// Pair 键值对
// vararg 可变参数列表 允许传入任意多个Pair类型参数
// Lambda表达式内获取到ContentValues的上下文
fun cvOf(vararg pairs: Pair<String, Any?>) = ContentValues().apply {
    for (pair in pairs) {
        val key = pair.first
        val value = pair.second
        when (value) {
            is Int -> put(key, value)
            is Long -> put(key, value)
            is Short -> put(key, value)
            is Float -> put(key, value)
            is Double -> put(key, value)
            is Boolean -> put(key, value)
            is String -> put(key, value)
            is Byte -> put(key, value)
            is ByteArray -> put(key, value)
            null -> putNull(key)
        }
    }
}
```

7.4 中的增可以简化成以下代码：

```kotlin
val values = cvOf(
    "name" to "Game of Thrones",
    "author" to "George Martin",
    "pages" to 720,
    "price" to 20.85
)
db.insert("Book", null, values)
```



## 第8章 跨程序共享数据，探究ContentProvider

#### 8.1 ContentProvider简介

ContentProvider 不同程序之间的数据共享 可以保证被访问数据的安全性 可以指定部分数据进行共享

ContentProvider的用法：

1. 使用现有的ContentProvider读取和操作相应程序中的数据
2. 创建自己的ContentProvider，给程序的数据提供外部访问接口

#### 8.2 运行时权限

###### 权限分类

普通权限：除了危险权限，剩余的大多是普通权限

危险权限：Android 10中一共11组30个危险权限

| 权限组                 | 权限                                                         |
| :--------------------- | :----------------------------------------------------------- |
| `CALENDAR`             | `READ_CALENDAR` `WRITE_CALENDAR`                             |
| `CAMERA`               | `CAMERA`                                                     |
| `CONTACTS`             | `READ_CONTACTS` `WRITE_CONTACTS` `GET_ACCOUNTS`              |
| `LOCATION`             | `ACCESS_FINE_LOCATION` `ACCESS_COARSE_LOCATION`              |
| `MICROPHONE`           | `RECORD_AUDIO`                                               |
| `PHONE`                | `READ_PHONE_STATE` `CALL_PHONE` `READ_CALL_LOG` `WRITE_CALL_LOG` `ADD_VOICEMAIL` `USE_SIP` `PROCESS_OUTGOING_CALLS` |
| `SENSORS`              | `BODY_SENSORS`                                               |
| `ACTIVITY_RECOGNITION` | `ACTIVITY_RECOGNITION`                                       |
| `SMS`                  | `SEND_SMS` `RECEIVE_SMS` `READ_SMS` `RECEIVE_WAP_PUSH` `RECEIVE_MMS` |
| `STORAGE`              | `READ_EXTERNAL_STORAGE` `WRITE_EXTERNAL_STORAGE`             |

特殊权限：使用相对较少

***注意*** 用户一旦同意了某个权限的申请后，同组的其他权限会被系统默认授予。但是，Android系统的权限分组随时可能会调整。

###### 申请权限

```kotlin
override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>,
                                        grantResults: IntArray) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    when (requestCode) {
        1 -> {
            if (grantResults.isNotEmpty()
                    && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                call()
            } else {
                // 如果用户拒绝授权，提示
                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show()
            }
        }
    }
}

// 先判断权限是否已授予
if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE)
        != PackageManager.PERMISSION_GRANTED) {
    ActivityCompat.requestPermissions(this,
            arrayOf(Manifest.permission.CALL_PHONE), 1)
} else {
    // 打电话
    call()
}
```

#### 8.3 访问其他程序中的数据

访问ContentProvider一般需要借助ContentResolver，通过Context中的getContentResolver()获取。

ContentResolver使用方式与SQLite类似，同样有增删改查操作，使用方式类似。

```kotlin
insert(Uri uri, ContentValues values)
delete(Uri uri, String where, String[] selectionArgs)
update(Uri uri, ContentValues values, String where, String[] selectionArgs)
query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
```

| 方法参数      | 对应SQL的部分             | 描述                             |
| ------------- | ------------------------- | -------------------------------- |
| uri           | from table_name           | 指定查询某个应用程序下的某一张表 |
| projection    | select column1, column2   | 指定查询的列名                   |
| selection     | where column = value      | 指定where的约束条件              |
| selectionArgs | -                         | 为where中的占位符提供具体的值    |
| sortOrder     | order by column1, column2 | 指定查询结果的排序方式           |

Uri：内容URI，唯一标识符。主要由 `authority` 和 `path` 两部分组成。

`authority `是用于对不同的应用程序做区分的，一般使用包名。`path ` 则是用于对同一应用的不同表做区分的。

```kotlin
// Uri的标准格式
content://authority/path
eg. content://com.example.app.provider/table1
// 解析成Uri对象
val uri = Uri.parse("content://com.example.app.provider/table1")
```

###### 例：读取系统联系人

```kotlin
// 需要申请运行时权限
private fun readContacts() {
    // 查询联系人数据
    // 使用?.和apply()简化代码
    contentResolver.query(
        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
        null, null, null, null
    )?.apply {
        while (moveToNext()) {
            // 获取联系人姓名
            val displayName =
                getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))
            // 获取联系人手机号
            val number =
                getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))
            contactsList.add("$displayName\n$number")
        }
        adapter.notifyDataSetChanged()
        close()
    }
}
```

#### 8.4 创建自己的ContentProvider

###### 创建ContentProvider的步骤

需要在AndroidManifest.xml添加

```xml
<!--  enabled 表示启用与否  exported 表示允许其他访问与否	-->
<provider
    android:name=".DatabaseProvider"
    android:authorities="com.example.databasetest.provider"
    android:enabled="true"
    android:exported="true" />
```

新建一个类并继承ContentProvider

```kotlin
class MyProvider : ContentProvider() {

    // 完成对数据库的创建和升级，true表示初始化完成，false表示失败
    override fun onCreate(): Boolean {
        return false
    }

    override fun query(
        uri: Uri, projection: Array<String>?, selection: String?,
        selectionArgs: Array<String>?, sortOrder: String?
    ): Cursor? {
        return null
    }

    override fun insert(uri: Uri, values: ContentValues?): Uri? {
        return null
    }

    override fun update(
        uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array<String>?
    ): Int {
        return 0
    }

    override fun delete(
        uri: Uri, selection: String?, selectionArgs: Array<String>?
    ): Int {
        return 0
    }

    // 根据传入的Uri返回相应的MIME类型
    override fun getType(uri: Uri) = when (uriMatcher.match(uri)) {
        return null
    }
}
```

Uri格式：

```kotlin
// 标准格式 表明期望访问该表中所有的数据
content://com.example.app.provider/table1
// 指定id 表明期望访问的是应用com.example.app.provider表table1中id为1的数据
content://com.example.app.provider/table1/1
```

可以使用通配符进行匹配：(用于match( ))

- *表示匹配任意长度的的任意字符
- #表示匹配任意长度的数字

```kotlin
// 匹配任意表的内容的Uri
content://com.example.app.provider/*
// 匹配table1表中任意一行数据的内容Uri
content://com.example.app.provider/table1/#
```

UriMatcher类：

```kotlin
// code 自定义代码
// 用于将URI与code联系起来
addURI(String authority, String path, int code)
// 传入的Uri，返回code
match(Uri uri)
```

```kotlin
init {
    uriMatcher.addURI("com.example.app.provider", "table1", table1Dir)
    uriMatcher.addURI("com.example.app.provider ", "table1/#", table1Item)
    uriMatcher.addURI("com.example.app.provider ", "table2", table2Dir)
    uriMatcher.addURI("com.example.app.provider ", "table2/#", table2Item)
}

override fun query(
    uri: Uri, projection: Array<String>?, selection: String?,
    selectionArgs: Array<String>?, sortOrder: String?
): Cursor? {
    when (uriMatcher.match(uri)) {
        table1Dir -> {
            // 查询table1表中的所有数据
        }
        table1Item -> {
            // 查询table1表中的单条数据
        }
        table2Dir -> {
            // 查询table2表中的所有数据
        }
        table2Item -> {
            // 查询table2表中的单条数据
        }
    }
    return null
}
```

MIME字符串：

- 必须以 `vnd.` 开头
- 如果内容URI以路径结尾，则后接 `android.cursor.dir/` ；如果内容以id结尾，则后接 `android.cursor.item/` 。
- 最后接上 `vnd.<authority>.<path>` 。

```kotlin
// content://com.example.app.provider/table1的MIME类型
vnd.android.cursor.dir/vnd.com.example.app.provider.table1
// content://com.example.app.provider/table1/1的MIME类型
vnd.android.cursor.item/vnd.com.example.app.provider.table1
```

***注意*** 所有的增删改查操作必须匹配到相应的URI格式才能进行。

###### 实现跨程序数据共享

```kotlin
class DatabaseProvider : ContentProvider() {

    private val bookDir = 0
    private val bookItem = 1
    private val categoryDir = 2
    private val categoryItem = 3
    private val authority = "com.example.databasetest.provider"
    private var dbHelper: MyDatabaseHelper? = null

    // by lazy 懒加载 只有当uriMatcher变量首次被调用的时候才会执行
    private val uriMatcher by lazy {
        val matcher = UriMatcher(UriMatcher.NO_MATCH)
        matcher.addURI(authority, "book", bookDir)
        matcher.addURI(authority, "book/#", bookItem)
        matcher.addURI(authority, "category", categoryDir)
        matcher.addURI(authority, "category/#", categoryItem)
        matcher
    }

    // context判空，为空则返回false，不会空执行Lambda表达式内的语句
    // 将表达式内最后一行作为返回值
    override fun onCreate() = context?.let {
        dbHelper = MyDatabaseHelper(it, "BookStore.db", 2)
        true
    } ?: false

    override fun query(
        uri: Uri,
        projection: Array<String>?,
        selection: String?,
        selectionArgs: Array<String>?,
        sortOrder: String?
    ) = dbHelper?.let {
        // 查询数据
        val db = it.readableDatabase
        val cursor = when (uriMatcher.match(uri)) {
            bookDir -> db.query("Book", projection, selection, selectionArgs, null, null, sortOrder)
            bookItem -> {
                // pathSegments 根据分隔符分割 0为path 1为id
                val bookId = uri.pathSegments[1]
                db.query("Book", projection, "id = ?", arrayOf(bookId), null, null, sortOrder)
            }
            categoryDir -> db.query(
                "Category",
                projection,
                selection,
                selectionArgs,
                null,
                null,
                sortOrder
            )
            categoryItem -> {
                val categoryId = uri.pathSegments[1]
                db.query(
                    "Category",
                    projection,
                    "id = ?",
                    arrayOf(categoryId),
                    null,
                    null,
                    sortOrder
                )
            }
            else -> null
        }
        cursor
    }

    // insert需要返回一个能够表示新增数据的URI
    override fun insert(uri: Uri, values: ContentValues?) = dbHelper?.let {
        // 添加数据
        val db = it.writableDatabase
        val uriReturn = when (uriMatcher.match(uri)) {
            bookDir, bookItem -> {
                val newBookId = db.insert("Book", null, values)
                Uri.parse("content://$authority/book/$newBookId")
            }
            categoryDir, categoryItem -> {
                val newCategoryId = db.insert("Category", null, values)
                Uri.parse("content://$authority/category/$newCategoryId")
            }
            else -> null
        }
        uriReturn
    }

    override fun update(
        uri: Uri,
        values: ContentValues?,
        selection: String?,
        selectionArgs: Array<String>?
    ) =
        dbHelper?.let {
            // 更新数据
            val db = it.writableDatabase
            val updatedRows = when (uriMatcher.match(uri)) {
                bookDir -> db.update("Book", values, selection, selectionArgs)
                bookItem -> {
                    val bookId = uri.pathSegments[1]
                    db.update("Book", values, "id = ?", arrayOf(bookId))
                }
                categoryDir -> db.update("Category", values, selection, selectionArgs)
                categoryItem -> {
                    val categoryId = uri.pathSegments[1]
                    db.update("Category", values, "id = ?", arrayOf(categoryId))
                }
                else -> 0
            }
            updatedRows
        } ?: 0

    override fun delete(uri: Uri, selection: String?, selectionArgs: Array<String>?) =
        dbHelper?.let {
            // 删除数据
            val db = it.writableDatabase
            val deletedRows = when (uriMatcher.match(uri)) {
                bookDir -> db.delete("Book", selection, selectionArgs)
                bookItem -> {
                    val bookId = uri.pathSegments[1]
                    db.delete("Book", "id = ?", arrayOf(bookId))
                }
                categoryDir -> db.delete("Category", selection, selectionArgs)
                categoryItem -> {
                    val categoryId = uri.pathSegments[1]
                    db.delete("Category", "id = ?", arrayOf(categoryId))
                }
                else -> 0
            }
            deletedRows
        } ?: 0

    override fun getType(uri: Uri) = when (uriMatcher.match(uri)) {
        bookDir -> "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book"
        bookItem -> "vnd.android.cursor.item/vnd.com.example.databasetest.provider.book"
        categoryDir -> "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category"
        categoryItem -> "vnd.android.cursor.item/vnd.com.example.databasetest.provider.category"
        else -> null
    }
}
```

对上述ContentProvider进行操作：

```kotlin
addData.setOnClickListener {
    // 添加数据
    val uri = Uri.parse("content://com.example.databasetest.provider/book")
    val values = contentValuesOf("name" to "A Clash of Kings", "author" to "George Martin", "pages" to 1040, "price" to 22.85)
    val newUri = contentResolver.insert(uri, values)
    bookId = newUri?.pathSegments?.get(1)
}
queryData.setOnClickListener {
    // 查询数据
    val uri = Uri.parse("content://com.example.databasetest.provider/book")
    contentResolver.query(uri, null, null, null, null)?.build {
        while (moveToNext()) {
            val name = getString(getColumnIndex("name"))
            val author = getString(getColumnIndex("author"))
            val pages = getInt(getColumnIndex("pages"))
            val price = getDouble(getColumnIndex("price"))
            Log.d("MainActivity", "book name is $name")
            Log.d("MainActivity", "book author is $author")
            Log.d("MainActivity", "book pages is $pages")
            Log.d("MainActivity", "book price is $price")
        }
        close()
    }
}
updateData.setOnClickListener {
    // 更新数据
    bookId?.let {
        val uri = Uri.parse("content://com.example.databasetest.provider/book/$it")
        val values = contentValuesOf("name" to "A Storm of Swords", "pages" to 1216, "price" to 24.05)
        contentResolver.update(uri, values, null, null)
    }
}
deleteData.setOnClickListener {
    // 删除数据
    bookId?.let {
        val uri = Uri.parse("content://com.example.databasetest.provider/book/$it")
        contentResolver.delete(uri, null, null)
    }
}
```

#### 8.5 Kotlin课堂：泛型和委托

###### 泛型的基本用法

泛型：在一般的编程模式下，我们需要给任何一个变量指定一个具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样编写出来的代码拥有更好的扩展性。

泛型定义方式：

- 定义泛型类
- 定义泛型方法

语法结构 `<T>` ，T并不固定，只是约定俗成，可以替换成任意英文字母或单词。

```kotlin
// 定义泛型类
class Myclass<T> {

    fun method(param: T): T {
        return param
    }
}
val myClass = MyClass<Int>()
val result = myClass.method(123)

// 定义泛型方法
class MyClass {

    fun <T> method(param: T): T {
        return param
    }
}
val myClass = MyClass()
val result = myClass.method<Int>(123)
// 可以自动推导类型
val results = myClass.method(123)
```

泛型可以设置泛型上界来对泛型的类型进行约束。

```kotlin
class MyClass {

    fun <T: Number> method(param: T): T {
        return param
    }
}
```

###### 委托

委托是一种设计模式，基本理念是：操作对象自己不去处理某段逻辑，而是会把工作委托给另一个辅助对象去处理。

- 类委托

核心思想是将一个类的具体实现委托给另一个类去完成。

```kotlin
class MySet<T>(val helperSet: HashSet<T>) : Set<T> by helperSet {

    override val size: Int
        get() = helperSet.size

    override fun contains(element: T) = helperSet.contains(element)

    override fun containsAll(elements: Collection<T>) = helperSet.containsAll(elements)

    override fun isEmpty() = helperSet.isEmpty()

    override fun iterator(): Iterator<T> = helperSet.iterator()
}
```

MySet的构造函数接收了一个HashSet参数，这便是辅助对象。然后Set接口的所有方法实现都是调用了辅助对象的相应方法，这边是一种委托模式。

类委托的意义：大部分方法的实现调用辅助对象中的方法，少部分的方法由自己来重写，设置加入一些自己独有的方法，让MySet就会成为一个全新的数据结构类。

`by` 关键字， 可以免去模板式代码，上面的例子可以简化成以下内容：

```kotlin
class MySet<T>(val helperSet: HashSet<T>) : Set<T> by helperSet {
}
```

如果需要对某个方法重新实现，只需要单独重写即可。如果需要添加新的方法，直接写就好了。

```kotlin
class MySet<T>(val helperSet: HashSet<T>) : Set<T> by helperSet {

    fun helloWorld() = println("Hello World")

    override fun isEmpty() = false

}
```

- 委托属性

核心思想是将一个属性(字段)的具体实现委托给另一个类去实现。

```kotlin
class MyClass {

    var p by Delegate()
}

class Delegate {

    var propValue: Any? = null

    // 第一个参数指明委托功能可以在什么类中使用
    // 第二个参数是Kotlin中的一个属性操作类
    // <*>表示不知道或者不关心泛型的具体类型
    operator fun getValue(myClass: MyClass, prop: KProperty<*>): Any? {
        return propValue
    }

    // value 的类型必须和getValue()方法返回值的类型一致
    // 当 p 设置为 val 的时候不需要setValue()方法
    operator fun setValue(myClass: MyClass, prop: KProperty<*>, value: Any?) {
        propValue = value
    }
}
```

当调用 `p` 属性的时候回自动调用Delegate类的getValue( )方法，当给 `p` 属性赋值的时候回自动调用Delegate类的setValue( )方法。

委托属性的意义： 懒加载、...

```kotlin
class Later<T>(val block: () -> T) {

    var value: Any? = null

    operator fun getValue(any: Any?, prop: KProperty<*>): T {
        // 如果value为空，则用代码块的返回值
        if (value == null) {
            value = block()
        }
        return value as T
    }
}

fun <T> later(block: () -> T) = Later(block)

// 将uriMatcher属性委托至Later类
private val uriMatcher by later {
    val matcher = UriMatcher(UriMatcher.NO_MATCH)
    matcher.addURI(authority, "book", bookDir)
    matcher.addURI(authority, "book/#", bookItem)
    matcher.addURI(authority, "category", categoryDir)
    matcher.addURI(authority, "category/#", categoryItem)
    matcher
}
```



## 第9章 丰富你的程序，运用手机多媒体

#### 9.1 将程序运行到手机上

现在Android手机早就不是什么稀罕物，几乎人手一部了，***如果***你还没有的话，赶紧去购买吧。

#### 9.2 使用通知

###### 创建通知渠道

Android 8.0系统引入通知渠道。

通知渠道一旦创建就不能修改。创建通知渠道前加系统版本判断。重要等级用户可以修改。

```kotlin
val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    // 渠道Id， 渠道名称， 重要等级
    // IMPORTANCE_MIN、IMPORTANCE_LOW、IMPORTANCE_DEFAULT、IMPORTANCE_HIGH
    val channel = NotificationChannel("normal", "Normal", NotificationManager.IMPORTANCE_DEFAULT)
    manager.createNotificationChannel(channel)
}
```

###### 通知的基本用法

使用AndroidX库中提供的NotificationCompat类，保证兼容性。