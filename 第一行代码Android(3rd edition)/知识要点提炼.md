# 第一行代码Android(第3版)

## 第5章 手机平板要兼顾，探究Fragment

1. 建议：向哪个类添加扩展函数就定义一个同名的Kotlin文件
2. 将扩展函数定义成顶层方法，可以让扩展函数有全局的访问域
3. 语法糖: 运算符重载(需要指定函数)

```kotlin
class Obj {
	operator fun plus(obj: Obj): Obj {
		// 处理逻辑		
	}
}
```

关键字 `operator` 和函数名 `plus` 是固定不变的，接收的参数和返回的值可以自定义

可以对同一个运算符进行多重重载

```kotlin
class Money(val value: Int) {

    operator fun plus(money: Money): Money {
        val sum = value + money.value
        return Money(sum)
    }

    operator fun plus(newValue: Int): Money {
        val sum = value + newValue
        return Money(sum)
    }
}
```

4. 语法糖表达式和实际调用函数对照表

一元前缀操作符

| 表达式 | 实际调用函数     |
| :----- | :--------------- |
| `+a`   | `a.unaryPlus()`  |
| `-a`   | `a.unaryMinus()` |
| `!a`   | `a.not()`        |

递增与递减

| 表达式 | 实际调用函数       |
| :----- | :----------------- |
| `a++`  | `a.inc()` + 见下文 |
| `a--`  | `a.dec()` + 见下文 |

算术运算符

| 表达式  | 实际调用函数   |
| :------ | :------------- |
| `a + b` | `a.plus(b)`    |
| `a - b` | `a.minus(b)`   |
| `a * b` | `a.times(b)`   |
| `a / b` | `a.div(b)`     |
| `a % b` | `a.rem(b)`     |
| `a..b`  | `a.rangeTo(b)` |

“In”操作符

| 表达式    | 实际调用函数     |
| :-------- | :--------------- |
| `a in b`  | `b.contains(a)`  |
| `a !in b` | `!b.contains(a)` |

索引访问操作符

| 表达式                | 实际调用函数             |
| :-------------------- | :----------------------- |
| `a[i]`                | `a.get(i)`               |
| `a[i, j]`             | `a.get(i, j)`            |
| `a[i_1, ……, i_n]`     | `a.get(i_1, ……, i_n)`    |
| `a[i] = b`            | `a.set(i, b)`            |
| `a[i, j] = b`         | `a.set(i, j, b)`         |
| `a[i_1, ……, i_n] = b` | `a.set(i_1, ……, i_n, b)` |

调用操作符

| 表达式            | 实际调用函数             |
| :---------------- | :----------------------- |
| `a()`             | `a.invoke()`             |
| `a(i)`            | `a.invoke(i)`            |
| `a(i, j)`         | `a.invoke(i, j)`         |
| `a(i_1, ……, i_n)` | `a.invoke(i_1, ……, i_n)` |

广义赋值

| 表达式   | 实际调用函数       |
| :------- | :----------------- |
| `a += b` | `a.plusAssign(b)`  |
| `a -= b` | `a.minusAssign(b)` |
| `a *= b` | `a.timesAssign(b)` |
| `a /= b` | `a.divAssign(b)`   |
| `a %= b` | `a.remAssign(b)`   |

相等与不等操作符

| 表达式   | 实际调用函数                      |
| :------- | :-------------------------------- |
| `a == b` | `a?.equals(b) ?: (b === null)`    |
| `a != b` | `!(a?.equals(b) ?: (b === null))` |

比较操作符

| 表达式   | 实际调用函数          |
| :------- | :-------------------- |
| `a > b`  | `a.compareTo(b) > 0`  |
| `a < b`  | `a.compareTo(b) < 0`  |
| `a >= b` | `a.compareTo(b) >= 0` |
| `a <= b` | `a.compareTo(b) <= 0` |

## 第6章 全局大喇叭，详解广播机制

#### 6.1 广播机制简介

标准广播：异步执行 所有BroadcastReceiver几乎同时收到广播 无法拦截

有序广播：同步执行 上一级处理完后才到下一级处理 可以拦截

#### 6.2 接收系统广播

静态注册：XML注册 开机有效 隐式广播不可(8.0后)

动态注册：代码注册 注册有效 手动注销 

完整系统广播列表：

```
<Android SDK>/platforms/<Android Api版本>/data/broadcast_actions.txt
```

***注意*** ：

不要在广播的onReceive( )方法中进行耗时操作，广播是运行在主线程，长时间未响应会导致ANR。

同时在BroadcastReceiver中创建子线程进行操作是不可靠的，其所在进程可能会被杀死

#### 6.3 发送自定义广播

```kotlin
// 发送广播时 指定接收广播的包名
// 否则静态广播无法接收到
intent.setPackage(packageName)
```

```kotlin
// 有序广播通过设置 priority 设置广播接收优先级
abortBroadcast() // 拦截广播
```

#### 6.4 广播最佳实践

在BaseActivity中注册强制下线的广播，不需要在每个Activity都添加接收到强制下线广播弹窗的逻辑

在onResume( )和onPause( )中注册和注销广播可以保证只有栈顶的Activity才能接收到广播

#### 6.5 Kotlin课堂：高阶函数详解

定义高阶函数

函数类型：以传入参数的类型以及返回值类型为分类标准

将函数类型当做参数或者返回值的就是高阶函数

函数类型可以定义到指定类当中，调用高阶函数时，传入的函数自动拥有指定类的上下文

```kotlin
fun StringBuilder.build(block: StringBuilder.() -> Unit): StringBuilder {
    block()
    return this
}
val list = listOf("Apple", "Banana", "Orange", "Pear", "Grape")
val result = StringBuilder().build {
    append("Start eating fruits.\n")
    for (fruit in list) {
        append(fruit).append("\n")
    }
    append("Ate all fruits.")
}
println(result.toString())
// 	  输出结果
//    Start eating fruits.
//    Apple
//    Banana
//    Orange
//    Pear
//    Grape
//    Ate all fruits.
```

内联函数

`inline` 

Kotlin编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方， 减少额外的内存和性能开销

`noinline`

`inline` 会进行函数返回，`noinline` 只能进行局部返回

`crossinline`

禁用 `inline` 函数当中的 `return` ，但是可以继续使用局部返回



## 第7章 数据存储全方案，详细持久化技术

#### 7.1 持久化技术简介

文件存储、SharedPreferences存储以及数据库存储

#### 7.2 文件存储

文件存储： 不对存储数据进行处理  	适合存储简单的文本数据或者二进制数据

###### 写

```kotlin
private fun save(inputText: String) {
    try {
        // 第一个参数为文件名，默认路径为/data/data/<package name>/files/
        // 第二个参数为模式， MODE_PRIVATE 覆盖原文件 MODE_APPEND 追加内容
        val output = openFileOutput("data", Context.MODE_PRIVATE)
        val writer = BufferedWriter(OutputStreamWriter(output))
        // use 内置扩展函数 Lambda表达式内的代码执行完后自动关闭外层的流
        writer.use {
            it.write(inputText)
        }
    } catch (e: IOException) {
        e.printStackTrace()
    }
}
```

###### 读

```kotlin
private fun load(): String {
    val content = StringBuilder()
    try {
        // 参数为文件名，默认路径为/data/data/<package name>/files/
        val input = openFileInput("data")
        val reader = BufferedReader(InputStreamReader(input))
        reader.use {
            // forEachLine 内置扩展函数 将读取到的每行内容回调至Lambda表达式中
            reader.forEachLine {
                content.append(it)
            }
        }
    } catch (e: IOException) {
        e.printStackTrace()
    }
    return content.toString()
}
```

#### 7.3 SharedPreferences存储

SharedPreferences存储： 键值对存储 	根据数据类型存储 	XML格式存储

###### 存

```kotlin
// Context类中的 getSharedPreferences()方法
// 第一个参数指定文件名 默认路径为/data/data/<package name>/shared_prefs/
// 第二个参数指定模式 MODE_PRIVATE 表示只有当前应用可读写
// Activity类中的 getSharedPreferences()方法
// 只接受指定模式参数 名称默认使用当前Activity的类名
val editor = getSharedPreferences("data", Context.MODE_PRIVATE).edit()
// Key-Value
editor.putString("name", "Tom")
editor.putInt("age", 28)
editor.putBoolean("married", false)
editor.apply()
```

###### 取

```kotlin
val prefs = getSharedPreferences("data", Context.MODE_PRIVATE)
// Key - Default
val name = prefs.getString("name", "")
val age = prefs.getInt("age", 0)
val married = prefs.getBoolean("married", false)
```

#### 7.4 SQLite数据库存储

SQLite数据库存储： 适合存储数据量较大、结构较复杂的数据 	数据库格式存储

###### 创

```kotlin
// context 上下文
// name 数据库名称
// null 自定义Cursor
// version 数据库版本号 version >= 1
// 数据库文件默认路径：/data/data/<package name>/databases/
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    // 数据库库类型 integer 整型 real 浮点型 text 文本类型 blob 二进制类型
    // primary key 主键 autoincrement 自增长。
    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }
}

val dbHelper = MyDatabaseHelper(this, "BookStore.db", 1)
// 当表不存在时创建表，表存在则获取表
dbHelper.writableDatabase
```

###### 升

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    private val createCategory = "create table Category (" +
            "id integer primary key autoincrement," +
            "category_name text," +
            "category_code integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }
	// newVersion > oldVersion 时执行
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 如果表存在则删除
        db.execSQL("drop table if exists Book")
        db.execSQL("drop table if exists Category")
        onCreate(db)
    }
}

val dbHelper = MyDatabaseHelper(this, "BookStore.db", 2)
dbHelper.writableDatabase
```

###### 增

```kotlin
val db = dbHelper.writableDatabase
val values1 = ContentValues().apply {
    // 开始组装第一条数据
    put("name", "The Da Vinci Code")
    put("author", "Dan Brown")
    put("pages", 454)
    put("price", 16.96)
}
// insert(String table, String nullColumnHack, ContentValues values)
// table 表名
// nullColumnHack 在未指定添加数据时为指定空列赋值NULL， 一般填null
// values ContentValues对象
db.insert("Book", null, values1) // 插入第一条数据
val values2 = ContentValues().apply {
    // 开始组装第二条数据
    put("name", "The Lost Symbol")
    put("author", "Dan Brown")
    put("pages", 510)
    put("price", 19.95)
}
db.insert("Book", null, values2) // 插入第二条数据
```

###### 改

```kotlin
val db = dbHelper.writableDatabase
val values = ContentValues()
values.put("price", 10.99)
// update(String table, ContentValues values, String whereClause, String[] whereArgs)
// table 表名
// values ContentValues对象
// whereClause 更新指定参数的行
// whereArgs 指定的参数
val rows = db.update("Book", values, "name = ?", arrayOf("The Da Vinci Code"))
```

###### 删

```kotlin
val db = dbHelper.writableDatabase
// delete(String table, String whereClause, String[] whereArgs)
// table 表名
// whereClause 指定参数的行
// whereArgs 指定的参数
db.delete("Book", "pages > ?", arrayOf("500"))
```

###### 查

```kotlin
query(String table, String[] columns, String selection,
      String[] selectionArgs, String groupBy, String having,
      String orderBy)
```

| query方法参数 | 对应SQL的部分             | 描述                          |
| ------------- | ------------------------- | ----------------------------- |
| table         | from table_name           | 指定查询的表名                |
| columns       | select column1, column2   | 指定查询的列名                |
| selection     | where column = value      | 指定where的约束条件           |
| selectionArgs | -                         | 为where中的占位符提供具体的值 |
| groupBy       | group by column           | 指定需要的group by的列        |
| having        | having column = value     | 对group by后的结果进一步约束  |
| orderBy       | order by column1, column2 | 指定查询结果的排序方式        |

```kotlin
val db = dbHelper.writableDatabase
// 查询Book表中所有的数据
val cursor = db.query("Book", null, null, null, null, null, null)
if (cursor.moveToFirst()) {
    do {
        // 遍历Cursor对象，取出数据并打印
        val name = cursor.getString(cursor.getColumnIndex("name"))
        val author = cursor.getString(cursor.getColumnIndex("author"))
        val pages = cursor.getInt(cursor.getColumnIndex("pages"))
        val price = cursor.getDouble(cursor.getColumnIndex("price"))
        Log.d("MainActivity", "book name is $name")
        Log.d("MainActivity", "book author is $author")
        Log.d("MainActivity", "book pages is $pages")
        Log.d("MainActivity", "book price is $price")
    } while (cursor.moveToNext())
}
cursor.close()
```

###### 使用SQL操作数据库

添加数据：

```kotlin
db.execSQL(
    "insert into Book (name, author, pages, price) values(?, ?, ?, ?)",
    arrayOf("The Da Vinci Code", "Dan Brown", "454", "16.96")
)
```

更新数据：

```kotlin
db.execSQL(
    "update Book set price = ? where name = ?",
    arrayOf("10.99", "The Da Vinci Code")
)
```

删除数据：

```kotlin
db.execSQL("delete from Book where paged > ?", arrayOf("500"))
```

查询数据：

```kotlin
val cursor = db.rawQuery("select * from Book", null)
```

#### 7.5 SQLite数据库的最佳实践

事务：保证一系列的操作要么全部成功，要么一个都不会完成。

```kotlin
val db = dbHelper.writableDatabase
db.beginTransaction() // 开启事务
try {
    db.delete("Book", null, null)
    if (true) {
        // 在这里手动抛出一个异常，让事务失败
        throw NullPointerException()
    }
    val values = cvOf(
        "name" to "Game of Thrones",
        "author" to "George Martin",
        "pages" to 720,
        "price" to 20.85
    )
    db.insert("Book", null, values)
    db.setTransactionSuccessful() // 事务已经执行成功
} catch (e: Exception) {
    e.printStackTrace()
} finally {
    db.endTransaction() // 结束事务
}
```

数据库版本更新：

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    private val createCategory = "create table Category (" +
            "id integer primary key autoincrement," +
            "category_name text," +
            "category_code integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 新增一张表
        if (oldVersion <= 1) {
            db.execSQL(createCategory)
        }
        // 原有表新增列
        if (oldVersion <= 2) {
            db.execSQL("alter table Book add column category_id integer")
        }
    }
}
```

#### 7.6 Kotlin课堂：高阶函数的应用

###### 例1： SharedPreferences使用简化

```kotlin
// open函数内拥有SharedPreferences.Editor的上下文
fun SharedPreferences.edit(block: SharedPreferences.Editor.() -> Unit) {
    val editor = edit()
    editor.block()
    editor.apply()
}
```

7.3中的存可以简化成以下代码：

```kotlin
getSharedPreferences("data", Context.MODE_PRIVATE).edit {
    putString("name", "Tom")
    putInt("age", 28)
    putBoolean("married", false)
}
```

###### 例2： ContentValues使用简化

```kotlin
// Pair 键值对
// vararg 可变参数列表 允许传入任意多个Pair类型参数
// Lambda表达式内获取到ContentValues的上下文
fun cvOf(vararg pairs: Pair<String, Any?>) = ContentValues().apply {
    for (pair in pairs) {
        val key = pair.first
        val value = pair.second
        when (value) {
            is Int -> put(key, value)
            is Long -> put(key, value)
            is Short -> put(key, value)
            is Float -> put(key, value)
            is Double -> put(key, value)
            is Boolean -> put(key, value)
            is String -> put(key, value)
            is Byte -> put(key, value)
            is ByteArray -> put(key, value)
            null -> putNull(key)
        }
    }
}
```

7.4 中的增可以简化成以下代码：

```kotlin
val values = cvOf(
    "name" to "Game of Thrones",
    "author" to "George Martin",
    "pages" to 720,
    "price" to 20.85
)
db.insert("Book", null, values)
```



## 第8章 跨程序共享数据，探究ContentProvider

#### 8.1 ContentProvider简介

ContentProvider 不同程序之间的数据共享 可以保证被访问数据的安全性 可以指定部分数据进行共享

ContentProvider的用法：

1. 使用现有的ContentProvider读取和操作相应程序中的数据
2. 创建自己的ContentProvider，给程序的数据提供外部访问接口

#### 8.2 运行时权限

###### 权限分类

普通权限：除了危险权限，剩余的大多是普通权限

危险权限：Android 10中一共11组30个危险权限

| 权限组                 | 权限                                                         |
| :--------------------- | :----------------------------------------------------------- |
| `CALENDAR`             | `READ_CALENDAR` `WRITE_CALENDAR`                             |
| `CAMERA`               | `CAMERA`                                                     |
| `CONTACTS`             | `READ_CONTACTS` `WRITE_CONTACTS` `GET_ACCOUNTS`              |
| `LOCATION`             | `ACCESS_FINE_LOCATION` `ACCESS_COARSE_LOCATION`              |
| `MICROPHONE`           | `RECORD_AUDIO`                                               |
| `PHONE`                | `READ_PHONE_STATE` `CALL_PHONE` `READ_CALL_LOG` `WRITE_CALL_LOG` `ADD_VOICEMAIL` `USE_SIP` `PROCESS_OUTGOING_CALLS` |
| `SENSORS`              | `BODY_SENSORS`                                               |
| `ACTIVITY_RECOGNITION` | `ACTIVITY_RECOGNITION`                                       |
| `SMS`                  | `SEND_SMS` `RECEIVE_SMS` `READ_SMS` `RECEIVE_WAP_PUSH` `RECEIVE_MMS` |
| `STORAGE`              | `READ_EXTERNAL_STORAGE` `WRITE_EXTERNAL_STORAGE`             |

特殊权限：使用相对较少

***注意*** 用户一旦同意了某个权限的申请后，同组的其他权限会被系统默认授予。但是，Android系统的权限分组随时可能会调整。

###### 申请权限

```kotlin
override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>,
                                        grantResults: IntArray) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    when (requestCode) {
        1 -> {
            if (grantResults.isNotEmpty()
                    && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                call()
            } else {
                // 如果用户拒绝授权，提示
                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show()
            }
        }
    }
}

// 先判断权限是否已授予
if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE)
        != PackageManager.PERMISSION_GRANTED) {
    ActivityCompat.requestPermissions(this,
            arrayOf(Manifest.permission.CALL_PHONE), 1)
} else {
    // 打电话
    call()
}
```

#### 8.3 访问其他程序中的数据

访问ContentProvider一般需要借助ContentResolver，通过Context中的getContentResolver()获取。

ContentResolver使用方式与SQLite类似，同样有增删改查操作，使用方式类似。

```kotlin
insert(Uri uri, ContentValues values)
delete(Uri uri, String where, String[] selectionArgs)
update(Uri uri, ContentValues values, String where, String[] selectionArgs)
query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
```

| 方法参数      | 对应SQL的部分             | 描述                             |
| ------------- | ------------------------- | -------------------------------- |
| uri           | from table_name           | 指定查询某个应用程序下的某一张表 |
| projection    | select column1, column2   | 指定查询的列名                   |
| selection     | where column = value      | 指定where的约束条件              |
| selectionArgs | -                         | 为where中的占位符提供具体的值    |
| sortOrder     | order by column1, column2 | 指定查询结果的排序方式           |

Uri：内容URI，唯一标识符。主要由authority和path两部分组成。

authority是用于对不同的应用程序做区分的，一般使用包名。path则是用于对同一应用的不同表做区分的。

```kotlin
// Uri的标准格式
content://authority/path
eg. content://com.example.app.provider/table1
// 解析成Uri对象
val uri = Uri.parse("content://com.example.app.provider/table1")
```

###### 例：读取系统联系人

```kotlin
// 需要申请运行时权限
private fun readContacts() {
    // 查询联系人数据
    // 使用?.和apply()简化代码
    contentResolver.query(
        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
        null, null, null, null
    )?.apply {
        while (moveToNext()) {
            // 获取联系人姓名
            val displayName =
                getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))
            // 获取联系人手机号
            val number =
                getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))
            contactsList.add("$displayName\n$number")
        }
        adapter.notifyDataSetChanged()
        close()
    }
}
```

#### 8.4 创建自己的ContentProvider