# 第一行代码Android(第3版)

## 第5章 手机平板要兼顾，探究Fragment

1. 建议：向哪个类添加扩展函数就定义一个同名的Kotlin文件
2. 将扩展函数定义成顶层方法，可以让扩展函数有全局的访问域
3. 语法糖: 运算符重载(需要指定函数)

```kotlin
class Obj {
	operator fun plus(obj: Obj): Obj {
		// 处理逻辑		
	}
}
```

关键字 `operator` 和函数名 `plus` 是固定不变的，接收的参数和返回的值可以自定义

可以对同一个运算符进行多重重载

```kotlin
class Money(val value: Int) {

    operator fun plus(money: Money): Money {
        val sum = value + money.value
        return Money(sum)
    }

    operator fun plus(newValue: Int): Money {
        val sum = value + newValue
        return Money(sum)
    }
}
```

4. 语法糖表达式和实际调用函数对照表

一元前缀操作符

| 表达式 | 实际调用函数     |
| :----- | :--------------- |
| `+a`   | `a.unaryPlus()`  |
| `-a`   | `a.unaryMinus()` |
| `!a`   | `a.not()`        |

递增与递减

| 表达式 | 实际调用函数       |
| :----- | :----------------- |
| `a++`  | `a.inc()` + 见下文 |
| `a--`  | `a.dec()` + 见下文 |

算术运算符

| 表达式  | 实际调用函数   |
| :------ | :------------- |
| `a + b` | `a.plus(b)`    |
| `a - b` | `a.minus(b)`   |
| `a * b` | `a.times(b)`   |
| `a / b` | `a.div(b)`     |
| `a % b` | `a.rem(b)`     |
| `a..b`  | `a.rangeTo(b)` |

“In”操作符

| 表达式    | 实际调用函数     |
| :-------- | :--------------- |
| `a in b`  | `b.contains(a)`  |
| `a !in b` | `!b.contains(a)` |

索引访问操作符

| 表达式                | 实际调用函数             |
| :-------------------- | :----------------------- |
| `a[i]`                | `a.get(i)`               |
| `a[i, j]`             | `a.get(i, j)`            |
| `a[i_1, ……, i_n]`     | `a.get(i_1, ……, i_n)`    |
| `a[i] = b`            | `a.set(i, b)`            |
| `a[i, j] = b`         | `a.set(i, j, b)`         |
| `a[i_1, ……, i_n] = b` | `a.set(i_1, ……, i_n, b)` |

调用操作符

| 表达式            | 实际调用函数             |
| :---------------- | :----------------------- |
| `a()`             | `a.invoke()`             |
| `a(i)`            | `a.invoke(i)`            |
| `a(i, j)`         | `a.invoke(i, j)`         |
| `a(i_1, ……, i_n)` | `a.invoke(i_1, ……, i_n)` |

广义赋值

| 表达式   | 实际调用函数       |
| :------- | :----------------- |
| `a += b` | `a.plusAssign(b)`  |
| `a -= b` | `a.minusAssign(b)` |
| `a *= b` | `a.timesAssign(b)` |
| `a /= b` | `a.divAssign(b)`   |
| `a %= b` | `a.remAssign(b)`   |

相等与不等操作符

| 表达式   | 实际调用函数                      |
| :------- | :-------------------------------- |
| `a == b` | `a?.equals(b) ?: (b === null)`    |
| `a != b` | `!(a?.equals(b) ?: (b === null))` |

比较操作符

| 表达式   | 实际调用函数          |
| :------- | :-------------------- |
| `a > b`  | `a.compareTo(b) > 0`  |
| `a < b`  | `a.compareTo(b) < 0`  |
| `a >= b` | `a.compareTo(b) >= 0` |
| `a <= b` | `a.compareTo(b) <= 0` |

## 第6章 全局大喇叭，详解广播机制

#### 6.1 广播机制简介

标准广播：异步执行 所有BroadcastReceiver几乎同时收到广播 无法拦截

有序广播：同步执行 上一级处理完后才到下一级处理 可以拦截

#### 6.2 接收系统广播

静态注册：XML注册 开机有效 隐式广播不可(8.0后)

动态注册：代码注册 注册有效 手动注销 

完整系统广播列表：

```
<Android SDK>/platforms/<Android Api版本>/data/broadcast_actions.txt
```

***注意*** ：

不要在广播的onReceive( )方法中进行耗时操作，广播是运行在主线程，长时间未响应会导致ANR。

同时在BroadcastReceiver中创建子线程进行操作是不可靠的，其所在进程可能会被杀死

#### 6.3 发送自定义广播

```kotlin
// 发送广播时 指定接收广播的包名
// 否则静态广播无法接收到
intent.setPackage(packageName)
```

```kotlin
// 有序广播通过设置 priority 设置广播接收优先级
abortBroadcast() // 拦截广播
```

#### 6.4 广播最佳实践

在BaseActivity中注册强制下线的广播，不需要在每个Activity都添加接收到强制下线广播弹窗的逻辑

在onResume( )和onPause( )中注册和注销广播可以保证只有栈顶的Activity才能接收到广播

#### 6.5 Kotlin课堂：高阶函数详解

###### 定义高阶函数

函数类型：以传入参数的类型以及返回值类型为分类标准

将函数类型当做参数或者返回值的就是高阶函数

函数类型可以定义到指定类当中，调用高阶函数时，传入的函数自动拥有指定类的上下文

```kotlin
fun StringBuilder.build(block: StringBuilder.() -> Unit): StringBuilder {
    block()
    return this
}
val list = listOf("Apple", "Banana", "Orange", "Pear", "Grape")
val result = StringBuilder().build {
    append("Start eating fruits.\n")
    for (fruit in list) {
        append(fruit).append("\n")
    }
    append("Ate all fruits.")
}
println(result.toString())
// 	  输出结果
//    Start eating fruits.
//    Apple
//    Banana
//    Orange
//    Pear
//    Grape
//    Ate all fruits.
```

###### 内联函数

`inline` 

Kotlin编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方， 减少额外的内存和性能开销

`noinline`

`inline` 会进行函数返回，`noinline` 只能进行局部返回

`crossinline`

禁用 `inline` 函数当中的 `return` ，但是可以继续使用局部返回



## 第7章 数据存储全方案，详细持久化技术

#### 7.1 持久化技术简介

文件存储、SharedPreferences存储以及数据库存储

#### 7.2 文件存储

文件存储： 不对存储数据进行处理  	适合存储简单的文本数据或者二进制数据

###### 写

```kotlin
private fun save(inputText: String) {
    try {
        // 第一个参数为文件名，默认路径为/data/data/<package name>/files/
        // 第二个参数为模式， MODE_PRIVATE 覆盖原文件 MODE_APPEND 追加内容
        val output = openFileOutput("data", Context.MODE_PRIVATE)
        val writer = BufferedWriter(OutputStreamWriter(output))
        // use 内置扩展函数 Lambda表达式内的代码执行完后自动关闭外层的流
        writer.use {
            it.write(inputText)
        }
    } catch (e: IOException) {
        e.printStackTrace()
    }
}
```

###### 读

```kotlin
private fun load(): String {
    val content = StringBuilder()
    try {
        // 参数为文件名，默认路径为/data/data/<package name>/files/
        val input = openFileInput("data")
        val reader = BufferedReader(InputStreamReader(input))
        reader.use {
            // forEachLine 内置扩展函数 将读取到的每行内容回调至Lambda表达式中
            reader.forEachLine {
                content.append(it)
            }
        }
    } catch (e: IOException) {
        e.printStackTrace()
    }
    return content.toString()
}
```

#### 7.3 SharedPreferences存储

SharedPreferences存储： 键值对存储 	根据数据类型存储 	XML格式存储

###### 存

```kotlin
// Context类中的 getSharedPreferences()方法
// 第一个参数指定文件名 默认路径为/data/data/<package name>/shared_prefs/
// 第二个参数指定模式 MODE_PRIVATE 表示只有当前应用可读写
// Activity类中的 getSharedPreferences()方法
// 只接受指定模式参数 名称默认使用当前Activity的类名
val editor = getSharedPreferences("data", Context.MODE_PRIVATE).edit()
// Key-Value
editor.putString("name", "Tom")
editor.putInt("age", 28)
editor.putBoolean("married", false)
editor.apply()
```

###### 取

```kotlin
val prefs = getSharedPreferences("data", Context.MODE_PRIVATE)
// Key - Default
val name = prefs.getString("name", "")
val age = prefs.getInt("age", 0)
val married = prefs.getBoolean("married", false)
```

#### 7.4 SQLite数据库存储

SQLite数据库存储： 适合存储数据量较大、结构较复杂的数据 	数据库格式存储

###### 创

```kotlin
// context 上下文
// name 数据库名称
// null 自定义Cursor
// version 数据库版本号 version >= 1
// 数据库文件默认路径：/data/data/<package name>/databases/
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    // 数据库库类型 integer 整型 real 浮点型 text 文本类型 blob 二进制类型
    // primary key 主键 autoincrement 自增长。
    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
    }
}

val dbHelper = MyDatabaseHelper(this, "BookStore.db", 1)
// 当表不存在时创建表，表存在则获取表
dbHelper.writableDatabase
```

###### 升

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    private val createCategory = "create table Category (" +
            "id integer primary key autoincrement," +
            "category_name text," +
            "category_code integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }
	// newVersion > oldVersion 时执行
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 如果表存在则删除
        db.execSQL("drop table if exists Book")
        db.execSQL("drop table if exists Category")
        onCreate(db)
    }
}

val dbHelper = MyDatabaseHelper(this, "BookStore.db", 2)
dbHelper.writableDatabase
```

###### 增

```kotlin
val db = dbHelper.writableDatabase
val values1 = ContentValues().apply {
    // 开始组装第一条数据
    put("name", "The Da Vinci Code")
    put("author", "Dan Brown")
    put("pages", 454)
    put("price", 16.96)
}
// insert(String table, String nullColumnHack, ContentValues values)
// table 表名
// nullColumnHack 在未指定添加数据时为指定空列赋值NULL， 一般填null
// values ContentValues对象
db.insert("Book", null, values1) // 插入第一条数据
val values2 = ContentValues().apply {
    // 开始组装第二条数据
    put("name", "The Lost Symbol")
    put("author", "Dan Brown")
    put("pages", 510)
    put("price", 19.95)
}
db.insert("Book", null, values2) // 插入第二条数据
```

###### 改

```kotlin
val db = dbHelper.writableDatabase
val values = ContentValues()
values.put("price", 10.99)
// update(String table, ContentValues values, String whereClause, String[] whereArgs)
// table 表名
// values ContentValues对象
// whereClause 更新指定参数的行
// whereArgs 指定的参数
val rows = db.update("Book", values, "name = ?", arrayOf("The Da Vinci Code"))
```

###### 删

```kotlin
val db = dbHelper.writableDatabase
// delete(String table, String whereClause, String[] whereArgs)
// table 表名
// whereClause 指定参数的行
// whereArgs 指定的参数
db.delete("Book", "pages > ?", arrayOf("500"))
```

###### 查

```kotlin
query(String table, String[] columns, String selection,
      String[] selectionArgs, String groupBy, String having,
      String orderBy)
```

| query方法参数 | 对应SQL的部分             | 描述                          |
| ------------- | ------------------------- | ----------------------------- |
| table         | from table_name           | 指定查询的表名                |
| columns       | select column1, column2   | 指定查询的列名                |
| selection     | where column = value      | 指定where的约束条件           |
| selectionArgs | -                         | 为where中的占位符提供具体的值 |
| groupBy       | group by column           | 指定需要的group by的列        |
| having        | having column = value     | 对group by后的结果进一步约束  |
| orderBy       | order by column1, column2 | 指定查询结果的排序方式        |

```kotlin
val db = dbHelper.writableDatabase
// 查询Book表中所有的数据
val cursor = db.query("Book", null, null, null, null, null, null)
if (cursor.moveToFirst()) {
    do {
        // 遍历Cursor对象，取出数据并打印
        val name = cursor.getString(cursor.getColumnIndex("name"))
        val author = cursor.getString(cursor.getColumnIndex("author"))
        val pages = cursor.getInt(cursor.getColumnIndex("pages"))
        val price = cursor.getDouble(cursor.getColumnIndex("price"))
        Log.d("MainActivity", "book name is $name")
        Log.d("MainActivity", "book author is $author")
        Log.d("MainActivity", "book pages is $pages")
        Log.d("MainActivity", "book price is $price")
    } while (cursor.moveToNext())
}
cursor.close()
```

###### 使用SQL操作数据库

添加数据：

```kotlin
db.execSQL(
    "insert into Book (name, author, pages, price) values(?, ?, ?, ?)",
    arrayOf("The Da Vinci Code", "Dan Brown", "454", "16.96")
)
```

更新数据：

```kotlin
db.execSQL(
    "update Book set price = ? where name = ?",
    arrayOf("10.99", "The Da Vinci Code")
)
```

删除数据：

```kotlin
db.execSQL("delete from Book where paged > ?", arrayOf("500"))
```

查询数据：

```kotlin
val cursor = db.rawQuery("select * from Book", null)
```

#### 7.5 SQLite数据库的最佳实践

事务：保证一系列的操作要么全部成功，要么一个都不会完成。

```kotlin
val db = dbHelper.writableDatabase
db.beginTransaction() // 开启事务
try {
    db.delete("Book", null, null)
    if (true) {
        // 在这里手动抛出一个异常，让事务失败
        throw NullPointerException()
    }
    val values = cvOf(
        "name" to "Game of Thrones",
        "author" to "George Martin",
        "pages" to 720,
        "price" to 20.85
    )
    db.insert("Book", null, values)
    db.setTransactionSuccessful() // 事务已经执行成功
} catch (e: Exception) {
    e.printStackTrace()
} finally {
    db.endTransaction() // 结束事务
}
```

数据库版本更新：

```kotlin
class MyDatabaseHelper(val context: Context, name: String, version: Int) :
    SQLiteOpenHelper(context, name, null, version) {

    private val createBook = "create table Book (" +
            " id integer primary key autoincrement," +
            "author text," +
            "price real," +
            "pages integer," +
            "name text," +
            "category_id integer)"

    private val createCategory = "create table Category (" +
            "id integer primary key autoincrement," +
            "category_name text," +
            "category_code integer)"

    override fun onCreate(db: SQLiteDatabase) {
        db.execSQL(createBook)
        db.execSQL(createCategory)
        Toast.makeText(context, "Create succeeded", Toast.LENGTH_SHORT).show()
    }

    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // 新增一张表
        if (oldVersion <= 1) {
            db.execSQL(createCategory)
        }
        // 原有表新增列
        if (oldVersion <= 2) {
            db.execSQL("alter table Book add column category_id integer")
        }
    }
}
```

#### 7.6 Kotlin课堂：高阶函数的应用

###### 例1： SharedPreferences使用简化

```kotlin
// open函数内拥有SharedPreferences.Editor的上下文
fun SharedPreferences.edit(block: SharedPreferences.Editor.() -> Unit) {
    val editor = edit()
    editor.block()
    editor.apply()
}
```

7.3中的存可以简化成以下代码：

```kotlin
getSharedPreferences("data", Context.MODE_PRIVATE).edit {
    putString("name", "Tom")
    putInt("age", 28)
    putBoolean("married", false)
}
```

###### 例2： ContentValues使用简化

```kotlin
// Pair 键值对
// vararg 可变参数列表 允许传入任意多个Pair类型参数
// Lambda表达式内获取到ContentValues的上下文
fun cvOf(vararg pairs: Pair<String, Any?>) = ContentValues().apply {
    for (pair in pairs) {
        val key = pair.first
        val value = pair.second
        when (value) {
            is Int -> put(key, value)
            is Long -> put(key, value)
            is Short -> put(key, value)
            is Float -> put(key, value)
            is Double -> put(key, value)
            is Boolean -> put(key, value)
            is String -> put(key, value)
            is Byte -> put(key, value)
            is ByteArray -> put(key, value)
            null -> putNull(key)
        }
    }
}
```

7.4 中的增可以简化成以下代码：

```kotlin
val values = cvOf(
    "name" to "Game of Thrones",
    "author" to "George Martin",
    "pages" to 720,
    "price" to 20.85
)
db.insert("Book", null, values)
```



## 第8章 跨程序共享数据，探究ContentProvider

#### 8.1 ContentProvider简介

ContentProvider 不同程序之间的数据共享 可以保证被访问数据的安全性 可以指定部分数据进行共享

ContentProvider的用法：

1. 使用现有的ContentProvider读取和操作相应程序中的数据
2. 创建自己的ContentProvider，给程序的数据提供外部访问接口

#### 8.2 运行时权限

###### 权限分类

普通权限：除了危险权限，剩余的大多是普通权限

危险权限：Android 10中一共11组30个危险权限

| 权限组                 | 权限                                                         |
| :--------------------- | :----------------------------------------------------------- |
| `CALENDAR`             | `READ_CALENDAR` `WRITE_CALENDAR`                             |
| `CAMERA`               | `CAMERA`                                                     |
| `CONTACTS`             | `READ_CONTACTS` `WRITE_CONTACTS` `GET_ACCOUNTS`              |
| `LOCATION`             | `ACCESS_FINE_LOCATION` `ACCESS_COARSE_LOCATION`              |
| `MICROPHONE`           | `RECORD_AUDIO`                                               |
| `PHONE`                | `READ_PHONE_STATE` `CALL_PHONE` `READ_CALL_LOG` `WRITE_CALL_LOG` `ADD_VOICEMAIL` `USE_SIP` `PROCESS_OUTGOING_CALLS` |
| `SENSORS`              | `BODY_SENSORS`                                               |
| `ACTIVITY_RECOGNITION` | `ACTIVITY_RECOGNITION`                                       |
| `SMS`                  | `SEND_SMS` `RECEIVE_SMS` `READ_SMS` `RECEIVE_WAP_PUSH` `RECEIVE_MMS` |
| `STORAGE`              | `READ_EXTERNAL_STORAGE` `WRITE_EXTERNAL_STORAGE`             |

特殊权限：使用相对较少

***注意*** 用户一旦同意了某个权限的申请后，同组的其他权限会被系统默认授予。但是，Android系统的权限分组随时可能会调整。

###### 申请权限

```kotlin
override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>,
                                        grantResults: IntArray) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    when (requestCode) {
        1 -> {
            if (grantResults.isNotEmpty()
                    && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                call()
            } else {
                // 如果用户拒绝授权，提示
                Toast.makeText(this, "You denied the permission", Toast.LENGTH_SHORT).show()
            }
        }
    }
}

// 先判断权限是否已授予
if (ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE)
        != PackageManager.PERMISSION_GRANTED) {
    ActivityCompat.requestPermissions(this,
            arrayOf(Manifest.permission.CALL_PHONE), 1)
} else {
    // 打电话
    call()
}
```

#### 8.3 访问其他程序中的数据

访问ContentProvider一般需要借助ContentResolver，通过Context中的getContentResolver()获取。

ContentResolver使用方式与SQLite类似，同样有增删改查操作，使用方式类似。

```kotlin
insert(Uri uri, ContentValues values)
delete(Uri uri, String where, String[] selectionArgs)
update(Uri uri, ContentValues values, String where, String[] selectionArgs)
query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)
```

| 方法参数      | 对应SQL的部分             | 描述                             |
| ------------- | ------------------------- | -------------------------------- |
| uri           | from table_name           | 指定查询某个应用程序下的某一张表 |
| projection    | select column1, column2   | 指定查询的列名                   |
| selection     | where column = value      | 指定where的约束条件              |
| selectionArgs | -                         | 为where中的占位符提供具体的值    |
| sortOrder     | order by column1, column2 | 指定查询结果的排序方式           |

Uri：内容URI，唯一标识符。主要由 `authority` 和 `path` 两部分组成。

`authority `是用于对不同的应用程序做区分的，一般使用包名。`path ` 则是用于对同一应用的不同表做区分的。

```kotlin
// Uri的标准格式
content://authority/path
eg. content://com.example.app.provider/table1
// 解析成Uri对象
val uri = Uri.parse("content://com.example.app.provider/table1")
```

###### 例：读取系统联系人

```kotlin
// 需要申请运行时权限
private fun readContacts() {
    // 查询联系人数据
    // 使用?.和apply()简化代码
    contentResolver.query(
        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
        null, null, null, null
    )?.apply {
        while (moveToNext()) {
            // 获取联系人姓名
            val displayName =
                getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME))
            // 获取联系人手机号
            val number =
                getString(getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER))
            contactsList.add("$displayName\n$number")
        }
        adapter.notifyDataSetChanged()
        close()
    }
}
```

#### 8.4 创建自己的ContentProvider

###### 创建ContentProvider的步骤

需要在AndroidManifest.xml添加

```xml
<!--  enabled 表示启用与否  exported 表示允许其他访问与否	-->
<provider
    android:name=".DatabaseProvider"
    android:authorities="com.example.databasetest.provider"
    android:enabled="true"
    android:exported="true" />
```

新建一个类并继承ContentProvider

```kotlin
class MyProvider : ContentProvider() {

    // 完成对数据库的创建和升级，true表示初始化完成，false表示失败
    override fun onCreate(): Boolean {
        return false
    }

    override fun query(
        uri: Uri, projection: Array<String>?, selection: String?,
        selectionArgs: Array<String>?, sortOrder: String?
    ): Cursor? {
        return null
    }

    override fun insert(uri: Uri, values: ContentValues?): Uri? {
        return null
    }

    override fun update(
        uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array<String>?
    ): Int {
        return 0
    }

    override fun delete(
        uri: Uri, selection: String?, selectionArgs: Array<String>?
    ): Int {
        return 0
    }

    // 根据传入的Uri返回相应的MIME类型
    override fun getType(uri: Uri) = when (uriMatcher.match(uri)) {
        return null
    }
}
```

Uri格式：

```kotlin
// 标准格式 表明期望访问该表中所有的数据
content://com.example.app.provider/table1
// 指定id 表明期望访问的是应用com.example.app.provider表table1中id为1的数据
content://com.example.app.provider/table1/1
```

可以使用通配符进行匹配：(用于match( ))

- *表示匹配任意长度的的任意字符
- #表示匹配任意长度的数字

```kotlin
// 匹配任意表的内容的Uri
content://com.example.app.provider/*
// 匹配table1表中任意一行数据的内容Uri
content://com.example.app.provider/table1/#
```

UriMatcher类：

```kotlin
// code 自定义代码
// 用于将URI与code联系起来
addURI(String authority, String path, int code)
// 传入的Uri，返回code
match(Uri uri)
```

```kotlin
init {
    uriMatcher.addURI("com.example.app.provider", "table1", table1Dir)
    uriMatcher.addURI("com.example.app.provider ", "table1/#", table1Item)
    uriMatcher.addURI("com.example.app.provider ", "table2", table2Dir)
    uriMatcher.addURI("com.example.app.provider ", "table2/#", table2Item)
}

override fun query(
    uri: Uri, projection: Array<String>?, selection: String?,
    selectionArgs: Array<String>?, sortOrder: String?
): Cursor? {
    when (uriMatcher.match(uri)) {
        table1Dir -> {
            // 查询table1表中的所有数据
        }
        table1Item -> {
            // 查询table1表中的单条数据
        }
        table2Dir -> {
            // 查询table2表中的所有数据
        }
        table2Item -> {
            // 查询table2表中的单条数据
        }
    }
    return null
}
```

MIME字符串：

- 必须以 `vnd.` 开头
- 如果内容URI以路径结尾，则后接 `android.cursor.dir/` ；如果内容以id结尾，则后接 `android.cursor.item/` 。
- 最后接上 `vnd.<authority>.<path>` 。

```kotlin
// content://com.example.app.provider/table1的MIME类型
vnd.android.cursor.dir/vnd.com.example.app.provider.table1
// content://com.example.app.provider/table1/1的MIME类型
vnd.android.cursor.item/vnd.com.example.app.provider.table1
```

***注意*** 所有的增删改查操作必须匹配到相应的URI格式才能进行。

###### 实现跨程序数据共享

```kotlin
class DatabaseProvider : ContentProvider() {

    private val bookDir = 0
    private val bookItem = 1
    private val categoryDir = 2
    private val categoryItem = 3
    private val authority = "com.example.databasetest.provider"
    private var dbHelper: MyDatabaseHelper? = null

    // by lazy 懒加载 只有当uriMatcher变量首次被调用的时候才会执行
    private val uriMatcher by lazy {
        val matcher = UriMatcher(UriMatcher.NO_MATCH)
        matcher.addURI(authority, "book", bookDir)
        matcher.addURI(authority, "book/#", bookItem)
        matcher.addURI(authority, "category", categoryDir)
        matcher.addURI(authority, "category/#", categoryItem)
        matcher
    }

    // context判空，为空则返回false，不会空执行Lambda表达式内的语句
    // 将表达式内最后一行作为返回值
    override fun onCreate() = context?.let {
        dbHelper = MyDatabaseHelper(it, "BookStore.db", 2)
        true
    } ?: false

    override fun query(
        uri: Uri,
        projection: Array<String>?,
        selection: String?,
        selectionArgs: Array<String>?,
        sortOrder: String?
    ) = dbHelper?.let {
        // 查询数据
        val db = it.readableDatabase
        val cursor = when (uriMatcher.match(uri)) {
            bookDir -> db.query("Book", projection, selection, selectionArgs, null, null, sortOrder)
            bookItem -> {
                // pathSegments 根据分隔符分割 0为path 1为id
                val bookId = uri.pathSegments[1]
                db.query("Book", projection, "id = ?", arrayOf(bookId), null, null, sortOrder)
            }
            categoryDir -> db.query(
                "Category",
                projection,
                selection,
                selectionArgs,
                null,
                null,
                sortOrder
            )
            categoryItem -> {
                val categoryId = uri.pathSegments[1]
                db.query(
                    "Category",
                    projection,
                    "id = ?",
                    arrayOf(categoryId),
                    null,
                    null,
                    sortOrder
                )
            }
            else -> null
        }
        cursor
    }

    // insert需要返回一个能够表示新增数据的URI
    override fun insert(uri: Uri, values: ContentValues?) = dbHelper?.let {
        // 添加数据
        val db = it.writableDatabase
        val uriReturn = when (uriMatcher.match(uri)) {
            bookDir, bookItem -> {
                val newBookId = db.insert("Book", null, values)
                Uri.parse("content://$authority/book/$newBookId")
            }
            categoryDir, categoryItem -> {
                val newCategoryId = db.insert("Category", null, values)
                Uri.parse("content://$authority/category/$newCategoryId")
            }
            else -> null
        }
        uriReturn
    }

    override fun update(
        uri: Uri,
        values: ContentValues?,
        selection: String?,
        selectionArgs: Array<String>?
    ) =
        dbHelper?.let {
            // 更新数据
            val db = it.writableDatabase
            val updatedRows = when (uriMatcher.match(uri)) {
                bookDir -> db.update("Book", values, selection, selectionArgs)
                bookItem -> {
                    val bookId = uri.pathSegments[1]
                    db.update("Book", values, "id = ?", arrayOf(bookId))
                }
                categoryDir -> db.update("Category", values, selection, selectionArgs)
                categoryItem -> {
                    val categoryId = uri.pathSegments[1]
                    db.update("Category", values, "id = ?", arrayOf(categoryId))
                }
                else -> 0
            }
            updatedRows
        } ?: 0

    override fun delete(uri: Uri, selection: String?, selectionArgs: Array<String>?) =
        dbHelper?.let {
            // 删除数据
            val db = it.writableDatabase
            val deletedRows = when (uriMatcher.match(uri)) {
                bookDir -> db.delete("Book", selection, selectionArgs)
                bookItem -> {
                    val bookId = uri.pathSegments[1]
                    db.delete("Book", "id = ?", arrayOf(bookId))
                }
                categoryDir -> db.delete("Category", selection, selectionArgs)
                categoryItem -> {
                    val categoryId = uri.pathSegments[1]
                    db.delete("Category", "id = ?", arrayOf(categoryId))
                }
                else -> 0
            }
            deletedRows
        } ?: 0

    override fun getType(uri: Uri) = when (uriMatcher.match(uri)) {
        bookDir -> "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book"
        bookItem -> "vnd.android.cursor.item/vnd.com.example.databasetest.provider.book"
        categoryDir -> "vnd.android.cursor.dir/vnd.com.example.databasetest.provider.category"
        categoryItem -> "vnd.android.cursor.item/vnd.com.example.databasetest.provider.category"
        else -> null
    }
}
```

对上述ContentProvider进行操作：

```kotlin
addData.setOnClickListener {
    // 添加数据
    val uri = Uri.parse("content://com.example.databasetest.provider/book")
    val values = contentValuesOf("name" to "A Clash of Kings", "author" to "George Martin", "pages" to 1040, "price" to 22.85)
    val newUri = contentResolver.insert(uri, values)
    bookId = newUri?.pathSegments?.get(1)
}
queryData.setOnClickListener {
    // 查询数据
    val uri = Uri.parse("content://com.example.databasetest.provider/book")
    contentResolver.query(uri, null, null, null, null)?.build {
        while (moveToNext()) {
            val name = getString(getColumnIndex("name"))
            val author = getString(getColumnIndex("author"))
            val pages = getInt(getColumnIndex("pages"))
            val price = getDouble(getColumnIndex("price"))
            Log.d("MainActivity", "book name is $name")
            Log.d("MainActivity", "book author is $author")
            Log.d("MainActivity", "book pages is $pages")
            Log.d("MainActivity", "book price is $price")
        }
        close()
    }
}
updateData.setOnClickListener {
    // 更新数据
    bookId?.let {
        val uri = Uri.parse("content://com.example.databasetest.provider/book/$it")
        val values = contentValuesOf("name" to "A Storm of Swords", "pages" to 1216, "price" to 24.05)
        contentResolver.update(uri, values, null, null)
    }
}
deleteData.setOnClickListener {
    // 删除数据
    bookId?.let {
        val uri = Uri.parse("content://com.example.databasetest.provider/book/$it")
        contentResolver.delete(uri, null, null)
    }
}
```

#### 8.5 Kotlin课堂：泛型和委托

###### 泛型的基本用法

泛型：在一般的编程模式下，我们需要给任何一个变量指定一个具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样编写出来的代码拥有更好的扩展性。

泛型定义方式：

- 定义泛型类
- 定义泛型方法

语法结构 `<T>` ，T并不固定，只是约定俗成，可以替换成任意英文字母或单词。

```kotlin
// 定义泛型类
class Myclass<T> {

    fun method(param: T): T {
        return param
    }
}
val myClass = MyClass<Int>()
val result = myClass.method(123)

// 定义泛型方法
class MyClass {

    fun <T> method(param: T): T {
        return param
    }
}
val myClass = MyClass()
val result = myClass.method<Int>(123)
// 可以自动推导类型
val results = myClass.method(123)
```

泛型可以设置泛型上界来对泛型的类型进行约束。

```kotlin
class MyClass {

    fun <T: Number> method(param: T): T {
        return param
    }
}
```

###### 委托

委托是一种设计模式，基本理念是：操作对象自己不去处理某段逻辑，而是会把工作委托给另一个辅助对象去处理。

- 类委托

核心思想是将一个类的具体实现委托给另一个类去完成。

```kotlin
class MySet<T>(val helperSet: HashSet<T>) : Set<T> by helperSet {

    override val size: Int
        get() = helperSet.size

    override fun contains(element: T) = helperSet.contains(element)

    override fun containsAll(elements: Collection<T>) = helperSet.containsAll(elements)

    override fun isEmpty() = helperSet.isEmpty()

    override fun iterator(): Iterator<T> = helperSet.iterator()
}
```

MySet的构造函数接收了一个HashSet参数，这便是辅助对象。然后Set接口的所有方法实现都是调用了辅助对象的相应方法，这边是一种委托模式。

类委托的意义：大部分方法的实现调用辅助对象中的方法，少部分的方法由自己来重写，设置加入一些自己独有的方法，让MySet就会成为一个全新的数据结构类。

`by` 关键字， 可以免去模板式代码，上面的例子可以简化成以下内容：

```kotlin
class MySet<T>(val helperSet: HashSet<T>) : Set<T> by helperSet {
}
```

如果需要对某个方法重新实现，只需要单独重写即可。如果需要添加新的方法，直接写就好了。

```kotlin
class MySet<T>(val helperSet: HashSet<T>) : Set<T> by helperSet {

    fun helloWorld() = println("Hello World")

    override fun isEmpty() = false

}
```

- 委托属性

核心思想是将一个属性(字段)的具体实现委托给另一个类去实现。

```kotlin
class MyClass {

    var p by Delegate()
}

class Delegate {

    var propValue: Any? = null

    // 第一个参数指明委托功能可以在什么类中使用
    // 第二个参数是Kotlin中的一个属性操作类
    // <*>表示不知道或者不关心泛型的具体类型
    operator fun getValue(myClass: MyClass, prop: KProperty<*>): Any? {
        return propValue
    }

    // value 的类型必须和getValue()方法返回值的类型一致
    // 当 p 设置为 val 的时候不需要setValue()方法
    operator fun setValue(myClass: MyClass, prop: KProperty<*>, value: Any?) {
        propValue = value
    }
}
```

当调用 `p` 属性的时候回自动调用Delegate类的getValue( )方法，当给 `p` 属性赋值的时候回自动调用Delegate类的setValue( )方法。

委托属性的意义： 懒加载、...

```kotlin
class Later<T>(val block: () -> T) {

    var value: Any? = null

    operator fun getValue(any: Any?, prop: KProperty<*>): T {
        // 如果value为空，则用代码块的返回值
        if (value == null) {
            value = block()
        }
        return value as T
    }
}

fun <T> later(block: () -> T) = Later(block)

// 将uriMatcher属性委托至Later类
private val uriMatcher by later {
    val matcher = UriMatcher(UriMatcher.NO_MATCH)
    matcher.addURI(authority, "book", bookDir)
    matcher.addURI(authority, "book/#", bookItem)
    matcher.addURI(authority, "category", categoryDir)
    matcher.addURI(authority, "category/#", categoryItem)
    matcher
}
```



## 第9章 丰富你的程序，运用手机多媒体

#### 9.1 将程序运行到手机上

现在Android手机早就不是什么稀罕物，几乎人手一部了，***如果***你还没有的话，赶紧去购买吧。

#### 9.2 使用通知

###### 创建通知渠道

Android 8.0系统引入通知渠道。

通知渠道一旦创建就不能修改。创建通知渠道前加系统版本判断。重要等级用户可以修改。

通知的重要等级代表的是系统会使用不同的方式通知用户。

```kotlin
val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
    // 渠道Id， 渠道名称， 重要等级
    // IMPORTANCE_MIN、IMPORTANCE_LOW、IMPORTANCE_DEFAULT、IMPORTANCE_HIGH
    val channel = NotificationChannel("normal", "Normal", NotificationManager.IMPORTANCE_DEFAULT)
    manager.createNotificationChannel(channel)
}
```

###### 通知的基本用法

使用AndroidX库中提供的NotificationCompat类，保证兼容性。

```kotlin
val intent = Intent(this, NotificationActivity::class.java)
// 	第一个参数 上下文， 第二个参数传0， 第三个参数Intent， 第四个参数一般传0
//	getActivity可以替换为getService、getBroadcast
val pi = PendingIntent.getActivity(this, 0, intent, 0)
// 	第一个参数 上下文， 第二个参数 渠道id
val notification = NotificationCompat.Builder(this, "important")
    //  设置通知标题
    .setContentTitle("This is content title")
    //  设置通知正文内容 但是只能显示部分
    .setContentText("Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android.")
    //  设置小图标 只能用纯alpha图层图片进行设置 显示在状态栏上
    .setSmallIcon(R.drawable.small_icon)
    //  设置大图标 通知中显示的图标
    .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.large_icon))
	//	添加通知点击事件
    .setContentIntent(pi)
	//	当通知被点击后，自动取消通知
    .setAutoCancel(true)
    .build()
//  显示通知 第一个参数 通知id 保证id唯一
manager.notify(1, notification)
//	手动取消通知， 参数为通知id
manager.cancel(1)
```

通知显示长文本和图片

```kotlin
val notification = NotificationCompat.Builder(this, "important")
    //  设置通知标题
    .setContentTitle("This is content title")
    //  设置通知正文内容 但是只能显示部分
//    .setContentText("Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android.")
    //  设置通知长文本 
    .setStyle(NotificationCompat.BigTextStyle().bigText("Learn how to build notifications, send and sync data, and use voice actions. Get the official Android IDE and developer tools to build apps for Android."))
    //  设置通知显示图片
    .setStyle(NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(resources, R.drawable.big_image)))
    .build()
```

#### 9.3 调用摄像头和相册

```kotlin
class MainActivity : AppCompatActivity() {

    val takePhoto = 1
    val fromAlbum = 2
    lateinit var imageUri: Uri
    lateinit var outputImage: File

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // 相机拍照
        takePhotoBtn.setOnClickListener {
            // 创建File对象，用于存储拍照后的图片
            // 路径为：/sdcard/Android/data/<package name>/cache/
            outputImage = File(externalCacheDir, "output_image.jpg")
            if (outputImage.exists()) {
                outputImage.delete()
            }
            outputImage.createNewFile()
            // Android 7.0 开始直接使用本地真实路径的Uri被认为不安全 会抛出异常
            // FileProvider是一种特殊的ContentProvider，需要在AndroidManifest中注册
            // 利用ContentProvider的机制来对数据进行保护
            imageUri = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                // authority 可以是任意唯一的字符串
                FileProvider.getUriForFile(this,
                        "com.example.cameraalbumtest.fileprovider", outputImage);
            } else {
                Uri.fromFile(outputImage);
            }
            // 启动相机程序
            val intent = Intent("android.media.action.IMAGE_CAPTURE")
            // 设置相机输出图片的位置
            intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)
            startActivityForResult(intent, takePhoto)
        }
        // 相册选择
        fromAlbumBtn.setOnClickListener {
            // 打开文件选择器
            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT)
            intent.addCategory(Intent.CATEGORY_OPENABLE)
            // 设置过滤条件 指定只显示照片
            intent.type = "image/*"
            startActivityForResult(intent, fromAlbum)
        }
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        when (requestCode) {
            // 相机拍照
            takePhoto -> {
                if (resultCode == Activity.RESULT_OK) {
                    // 将拍摄的照片显示出来
                    val bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri))
                    imageView.setImageBitmap(rotateIfRequired(bitmap))
                }
            }
            // 相册选择
            fromAlbum -> {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    data.data?.let { uri ->
                        // 将选择的照片显示
                        // 如果图片过大 需要考虑对图片进行压缩再显示
                        val bitmap = getBitmapFromUri(uri)
                        imageView.setImageBitmap(bitmap)
                    }
                }
            }
        }
    }

    private fun getBitmapFromUri(uri: Uri) =
            contentResolver.openFileDescriptor(uri, "r")?.use {
                BitmapFactory.decodeFileDescriptor(it.fileDescriptor)
            }

    private fun rotateIfRequired(bitmap: Bitmap): Bitmap {
        val exif = ExifInterface(outputImage.path)
        val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,
                ExifInterface.ORIENTATION_NORMAL)
        return when (orientation) {
            ExifInterface.ORIENTATION_ROTATE_90 -> rotateBitmap(bitmap, 90)
            ExifInterface.ORIENTATION_ROTATE_180 -> rotateBitmap(bitmap, 180)
            ExifInterface.ORIENTATION_ROTATE_270 -> rotateBitmap(bitmap, 270)
            else -> bitmap
        }
    }

    private fun rotateBitmap(bitmap: Bitmap, degree: Int): Bitmap {
        val matrix = Matrix()
        matrix.postRotate(degree.toFloat())
        val rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0,
                bitmap.width, bitmap.height, matrix, true)
        bitmap.recycle()
        return rotatedBitmap
    }
}
```

```xml
// AndroidManifest.xml
<provider
    android:name="androidx.core.content.FileProvider"
    android:authorities="com.example.cameraalbumtest.fileprovider"
    android:exported="false"
    android:grantUriPermissions="true">
    <meta-data
        android:name="android.support.FILE_PROVIDER_PATHS"
        android:resource="@xml/file_paths" />
</provider>
// file_paths.xml
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path
        name="my_images"
        path="/" />
</paths>
```

#### 9.4 播放多媒体文件

音频、视频

###### 播放音频

MediaPlayer可以播放网络、本地以及应用程序内的音频。

MediaPlayer类中常用的方法

|     方法名      | 功能描述                                            |
| :-------------: | :-------------------------------------------------- |
| setDataSource() | 设置要播放的音频的位置                              |
|    prepare()    | 在开始播放之前调用，以完成准备工作                  |
|     start()     | 开始或继续播放音频                                  |
|     pause()     | 暂停播放音频                                        |
|     reset()     | 将MediaPlayer对象重置到刚刚创建的状态               |
|    seekTo()     | 从指定的位置开始播放音频                            |
|     stop()      | 停止播放音频。调用后的MediaPlayer对象无法再播放音频 |
|    release()    | 释放与MediaPlayer对象相关的资源                     |
|   isPlaying()   | 判断当前MediaPlayer是否正在播放音频                 |
|  getDuration()  | 获取载入的音频文件的时长                            |

```kotlin
class MainActivity : AppCompatActivity() {

    private val mediaPlayer = MediaPlayer()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initMediaPlayer()
        play.setOnClickListener {
            if (!mediaPlayer.isPlaying) {
                mediaPlayer.start() // 开始播放
            }
        }
        pause.setOnClickListener {
            if (mediaPlayer.isPlaying) {
                mediaPlayer.pause() // 暂停播放
            }
        }
        stop.setOnClickListener {
            if (mediaPlayer.isPlaying) {
                mediaPlayer.reset() // 停止播放
                // reset之后需要重新初始化
                initMediaPlayer()
            }
        }
    }

    private fun initMediaPlayer() {
        val assetManager = assets
        // 应用内的音频文件一般放在/src/main/assets/目录下
        val fd = assetManager.openFd("music.mp3")
        mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length)
        mediaPlayer.prepare()
    }

    override fun onDestroy() {
        super.onDestroy()
        mediaPlayer.stop()
        mediaPlayer.release()
    }
}
```

###### 播放视频

VideoView类

用法与MediaPlayer类似，只是MediaPlayer的一个封装。

视频格式的支持以及播放效率方面都有较大的不足。适于较小的视频播放。

VideoView类中常用的方法

|     方法名     | 功能描述                   |
| :------------: | :------------------------- |
| setVideoPath() | 设置要播放的视频文件的位置 |
|    start()     | 开始或继续播放视频         |
|    pause()     | 暂停播放视频               |
|    resume()    | 将视频从头开始播放         |
|    seekTo()    | 从指定的位置开始播放视频   |
|  isPlaying()   | 判断当前是否正在播放视频   |
| getDuration()  | 获取载入的视频文件的时长   |

```kotlin
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // VideoView不支持直接播放assets目录下的视频资源
        // 可以播放/res/raw/目录下的视频资源
        val uri = Uri.parse("android.resource://$packageName/${R.raw.video}")
        videoView.setVideoURI(uri)
        play.setOnClickListener {
            if (!videoView.isPlaying) {
                videoView.start() // 开始播放
            }
            Log.d("MainActivity", "video is playing")
        }
        pause.setOnClickListener {
            if (videoView.isPlaying) {
                videoView.pause() // 暂停播放
            }
        }
        replay.setOnClickListener {
            if (videoView.isPlaying) {
                videoView.resume() // 重新播放
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        videoView.suspend()
    }
}
```

#### 9.5 Kotlin课堂：使用infix函数构建更可读的语法

`infix` 函数是一种调整函数调用的语法规则的语法糖。

```kotlin
infix fun String.beginsWith(prefix: String) = startsWith(prefix)
// 一般调用
if ("Hello Kotlin".beginsWith("Hello")) {
    // 处理具体的逻辑
}
// 语法糖调用
if ("Hello Kotlin" beginsWith "Hello") {
    // 处理具体的逻辑
}
```

`infix` 函数的限制

- 不能定义顶层函数，必须是某个类的成员函数
- 必须接收且只能接收一个参数，参数类型不限制

```kotlin
infix fun <T> Collection<T>.has(element: T) = contains(element)

val list = listOf("Apple", "Banana", "Orange")
if (list has "Apple") {
    // 处理具体的逻辑
}
```



## 第10章 后台默默的劳动者，探究Service

#### 10.1 Service

Service是Android中实现持续后台运行的解决方案，适合执行不需要和用户交互且需要长时间执行的任务。

Service并不是运行在独立的进程当中，而是依赖于创建Service时所在应用程序的进程。当进程被杀掉时，依赖于该进程的Service也会停止运行。

Service并不会自动开启线程，所有代码默认在主线程中运行，需要手动创建子线程。

#### 10.2 Android多线程编程

###### 线程的基本用法

```kotlin
// 基本用法
class MyThread : Runnable {
    override fun run() {
        // 编写具体的逻辑
    }
}
val myThread = MyThread()
Thread(myThread).start()
// 简化用法 不需要专门定义类去实现Runnable接口
Thread {
    // 编写具体的逻辑
}.start()
// 再简化 Kotlin内置的顶层函数
thread {
    // 编写具体的逻辑
}
```

###### 在子线程中更新UI

Android的UI也是线程不安全的。

```kotlin
class MainActivity : AppCompatActivity() {

    val updateText = 1

    val handler = object : Handler() {
        override fun handleMessage(msg: Message) {
            // 在这里可以进行UI操作
            when (msg.what) {
                updateText -> textView.text = "Nice to meet you"
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        changeTextBtn.setOnClickListener {
            thread {
                val msg = Message()
                msg.what = updateText
                handler.sendMessage(msg) // 将Message对象发送出去
            }
        }
    }
}
```

###### 解析异步消息处理机

Message

Message是在线程之间传递的消息，可以携带少量数据。有 `what` 、 `arg1` 、 `arg2` 三个 `Int` 型字段以及一个 `Object` 型字段 `obj` 。

Handler

Handler主要用于发送和处理消息。

发送消息一般使用sendMessage( )方法和post( )方法等，最后用handleMessage( )方法处理消息。

MessageQueue

消息队列，用于存放所有通过Handler发送的未处理消息。

每个线程中只会有一个MessageQueue对象。

Looper

Looper是每个线程中MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环的过程。每当发现MessageQueue中存在一条消息时，便将其取出并传递给handleMessage( )方法进行处理。每个线程中只会有一个Looper对象。

###### 使用AsyncTask

AsyncTask的实现原理是异步消息处理机制。

在 Android 11当中被弃用，不看

#### 10.3 Service的基本用法

###### 定义Service

```kotlin
class MyService : Service() {

    override fun onBind(intent: Intent): IBinder {
        return mBinder
    }

    // Service创建时调用
    override fun onCreate() {
        super.onCreate()
        Log.d("MyService", "onCreate executed")
    }

    // 每次Service启动的时候调用
    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        Log.d("MyService", "onStartCommand executed")
        return super.onStartCommand(intent, flags, startId)
    }

    // 每次Service销毁的时候调用
    override fun onDestroy() {
        super.onDestroy()
        Log.d("MyService", "onDestroy executed")
    }
}
```

需要在AndroidManifest.xml中注册

```xml
<!--    exported 是否将这个Service暴露给外部其他程序访问
        enabled 是否启用这个Service-->
<service
    android:name=".MyService"
    android:enabled="true"
    android:exported="true" />
```

###### 启动和停止Service

```kotlin
val intent = Intent(this, MyService::class.java)
startService(intent) // 启动Service
val intent = Intent(this, MyService::class.java)
stopService(intent) // 停止Service
```

从Android 8.0 系统开始，应用的后台功能被大幅削减。如今只有当应用在前台可见状态的情况下，Service才能保证稳定运行。一旦应用进入后台，Service随时可能会被回收。

前台Service和WorkManager可以长期在后台执行一些任务。

###### Activity和Service进行通信

```kotlin
class MyService : Service() {

    private val mBinder = DownloadBinder()

    class DownloadBinder : Binder() {

        fun startDownload() {
            Log.d("MyService", "startDownload executed")
        }

        fun getProgress(): Int {
            Log.d("MyService", "getProgress executed")
            return 0
        }

    }

    override fun onBind(intent: Intent): IBinder {
        return mBinder
    }

    override fun onCreate() {
        super.onCreate()
        Log.d("MyService", "onCreate executed")
    }

    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
        Log.d("MyService", "onStartCommand executed")
        thread {
            // 处理具体的逻辑
            stopSelf()
        }
        return super.onStartCommand(intent, flags, startId)
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d("MyService", "onDestroy executed")
    }
}
```

```kotlin
class MainActivity : AppCompatActivity() {

    lateinit var downloadBinder: MyService.DownloadBinder

    // ServiceConnection 的匿名类
    private val connection = object : ServiceConnection {

        // 在Activity与Service绑定的时候执行
        // 在这可以拿到Service的IBinder，之后便可以调用其中的公开方法
        override fun onServiceConnected(name: ComponentName, service: IBinder) {
            downloadBinder = service as MyService.DownloadBinder
            downloadBinder.startDownload()
            downloadBinder.getProgress()
        }

        override fun onServiceDisconnected(name: ComponentName) {
            Log.d("MyService", "onServiceDisconnected")
        }

    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        startServiceBtn.setOnClickListener {
            val intent = Intent(this, MyService::class.java)
            startService(intent) // 启动Service
        }
        stopServiceBtn.setOnClickListener {
            val intent = Intent(this, MyService::class.java)
            stopService(intent) // 停止Service
        }
        bindServiceBtn.setOnClickListener {
            val intent = Intent(this, MyService::class.java)
            // Context.BIND_AUTO_CREATE 表示在绑定的时候自动创建Service
            // bindService执行Service的onCreate
            bindService(intent, connection, Context.BIND_AUTO_CREATE) // 绑定Service
        }
        unbindServiceBtn.setOnClickListener {
            // unbindService执行Service的onDestroy
            unbindService(connection) // 解绑Service
        }
        startIntentServiceBtn.setOnClickListener {
            // 打印主线程的id
            Log.d("MainActivity", "Thread id is ${Thread.currentThread().name}")
            val intent = Intent(this, MyIntentService::class.java)
            startService(intent)
        }
    }
}
```

#### 10.4 Service的生命周期

onCreate( ) 只会执行一次

onStartCommand( ) 每启动一次执行一遍

onDestroy( ) 只需执行一次

startService和stopService成对存在

bindService和unbindService成对存在

#### 10.5 Service的更多技巧

###### 使用前台Service

使用前台Service需要权限

```xml
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
```

```kotlin
override fun onCreate() {
    super.onCreate()
    Log.d("MyService", "onCreate executed")
    val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel("my_service", "前台Service通知", NotificationManager.IMPORTANCE_DEFAULT)
        manager.createNotificationChannel(channel)
    }
    val intent = Intent(this, MainActivity::class.java)
    val pi = PendingIntent.getActivity(this, 0, intent, 0)
    val notification = NotificationCompat.Builder(this, "my_service")
            .setContentTitle("This is content title")
            .setContentText("This is content text")
            .setSmallIcon(R.drawable.small_icon)
            .setLargeIcon(BitmapFactory.decodeResource(resources, R.drawable.large_icon))
            .setContentIntent(pi)
            .build()
    // 调用startForeground即可让Service变成前台Service
    // 通知会一直显示在系统状态栏中 可以被手动清理
    startForeground(1, notification)
}
```

###### 使用IntentService

IntentService，异步的、会自动停止的Service。

在onStartCommand( )方法中自动开启子线程，线程内代码执行完毕后自我了结。

```kotlin
// 字符串可以任意指定，只在调试的时候有效
class MyIntentService : IntentService("MyIntentService") {

    override fun onHandleIntent(intent: Intent?) {
        // 打印当前线程的id
        Log.d("MyIntentService", "Thread id is ${Thread.currentThread().name}")
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d("MyIntentService", "onDestroy executed")
    }

}
// 打印主线程的id
Log.d("MainActivity", "Thread id is ${Thread.currentThread().name}")
val intent = Intent(this, MyIntentService::class.java)
startService(intent)
```

#### 10.6 Kotlin课堂：泛型的高级特性

###### ***不甚理解***

###### 对泛型进行实化

所有基于JVM的语言，泛型功能都是通过类型擦除机制来实现的。

类型擦除： 泛型对于类型的约束只在编译时期存在，JVM是识别不出来我们在代码中指定的泛型类型。

泛型实化条件

- 函数必须是内联( `inline` )函数
- 泛型实化关键字 `reified` 

```kotlin
// 获取泛型的类型
inline fun <reified T> getGenericType() = T::class.java
```

```kotlin
fun main() {
    val result1 = getGenericType<String>()
    val result2 = getGenericType<Int>()
    println("result1 is $result1")
    println("result2 is $result2")
}
//	-------  输出  ------
//	result1 is class java.lang.String
//  result2 is class java.lang.Integer
```

###### 泛型实化的应用

```kotlin
// 简化启动Activity的代码
inline fun <reified T> startActivity(context: Context, block: Intent.() -> Unit) {
    val intent = Intent(context, T::class.java)
    block(intent)
    context.startActivity(intent)
}
// 一般写法
val intent = Intent(this, MainActivity::class.java)
intent.putExtra("param1", "data")
intent.putExtra("param2", 123)
startActivity(intent)
// 简化写法
startActivity<MainActivity>(this) {
    putExtra("param1", "data")
    putExtra("param2", 123)
}
```

###### 泛型的协变

一个泛型类或者泛型接口中的方法，它的参数列表是接收数据的地方，可以称之为 `in` 位置，而它的返回值是输出数据的地方，可以称之为 `out` 位置。

假如定义了一个 `MyClass<T>` 的泛型类， 其中A是B的子类型，同时 `MyClass<A>` 又是 `MyClass<B>` 的子类型，那么我们就可以称MyClass在T这个泛型上是协变的。

那么 `MyClass<T>` 类中的所有方法都不能接收T类型的参数。T只能出现在out位置上，不能出现在in位置上。

```kotlin
// val关键字 构造函数中保证泛型T是只读的即可
class SimpleData<out T>(val data: T?) {

    fun get(): T? {
        return data
    }
}
```

###### 泛型的逆变

假如定义了一个 `MyClass<T>` 的泛型类， 其中A是B的子类型，同时 `MyClass<B>` 又是 `MyClass<A>` 的子类型，那么我们就可以称MyClass在T这个泛型上是协变的。

让一些方法能兼容

## 第11章 看看精彩的世界，使用网络技术

#### 11.1 WebView的用法

访问网络需要权限

```xml
    <uses-permission android:name="android.permission.INTERNET" />
```

```kotlin
webView.settings.setJavaScriptEnabled(true)
webView.webViewClient = WebViewClient()
webView.loadUrl("https://www.baidu.com")
```

#### 11.2 使用HTTP访问网络

HTTP：客户端想服务器发送一条HTTP请求，服务器收到请求之后会返回一些数据给客户端，客户端对数据进行解析和处理即可。

Android 9.0 系统开始，应用程序默认只允许使用HTTPS类型的网络请求，禁止HTTP类型的明文数据传输方式。

###### 使用HttpURLConnection

请求方式：GET和POST。GET表示从服务器获取数据，POST表示将数据提交给服务器。

```kotlin
// 请求方式GET
connection.requestMethod = "GET"
// 请求方式POST
connection.requestMethod = "POST"
val output = DataOutputStream(connection.outputStream)
output.writeBytes("username=admin&password=123456")
```

完整示例：

```kotlin
fun sendHttpRequest(address: String, listener: HttpCallbackListener) {
    // 开启线程发送网络请求
    thread {
        var connection: HttpURLConnection? = null
        try {
            val response = StringBuilder()
            val url = URL(address)
            connection = url.openConnection() as HttpURLConnection
            // 连接超时毫秒数
            connection.connectTimeout = 8000
            // 读取超时毫秒数
            connection.readTimeout = 8000
            // 获取服务器返回的输入流
            val input = connection.inputStream
            // 对获取到的输入流进行读取
            val reader = BufferedReader(InputStreamReader(input))
            reader.use {
                reader.forEachLine {
                    response.append(it)
                }
            }
            // 回调onFinish()方法
            listener.onFinish(response.toString())
        } catch (e: Exception) {
            e.printStackTrace()
            // 回调onError()方法
            listener.onError(e)
        } finally {
            // 关闭连接
            connection?.disconnect()
        }
    }
}
```

###### 使用OkHttp

使用OkHttp需要添加依赖

```kotlin
fun sendOkHttpRequest(address: String, callback: okhttp3.Callback) {
    // GET
    val client = OkHttpClient()
    val request = Request.Builder()
    .url(address)
    .build()
    client.newCall(request).enqueue(callback)
    // POST
    val requestBody = FormBody.Builder()
                .add("username", "admin")
                .add("password", "123456")
                .build()
    val requestPost = Request.Builder()
    			.url(address)
    			.post(requestBody)
    			.build()
    client.newCall(requestPost).enqueue(callback)
}
```

#### 11.3 解析XML格式数据

XML格式常用解析方式：Pull解析和SAX解析。

###### Pull解析方式

```kotlin
// 传入获取到的XML格式字符串
private fun parseXMLWithPull(xmlData: String) {
    try {
        // 创建解析实例
        val factory = XmlPullParserFactory.newInstance()
        val xmlPullParser = factory.newPullParser()
        xmlPullParser.setInput(StringReader(xmlData))
        var eventType = xmlPullParser.eventType
        var id = ""
        var name = ""
        var version = ""
        while (eventType != XmlPullParser.END_DOCUMENT) {
            val nodeName = xmlPullParser.name
            when (eventType) {
                // 开始解析某个节点
                XmlPullParser.START_TAG -> {
                    when (nodeName) {
                        // nextText 获取节点内容
                        "id" -> id = xmlPullParser.nextText()
                        "name" -> name = xmlPullParser.nextText()
                        "version" -> version = xmlPullParser.nextText()
                    }
                }
                // 完成解析某个节点
                XmlPullParser.END_TAG -> {
                    if ("app" == nodeName) {
                        Log.d("MainActivity", "id is $id")
                        Log.d("MainActivity", "name is $name")
                        Log.d("MainActivity", "version is $version")
                    }
                }
            }
            eventType = xmlPullParser.next()
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}
```

###### SAX解析方式

SAX解析，通常情况下会新建类继承自DefaultHandler。

```kotlin
class MyHandler : DefaultHandler() {

    // 开始解析时调用
    override fun startDocument() {
    }

    // 解析节点时调用
    override fun startElement(uri: String, localName: String, qName: String, attributes: Attributes) {
    }

    override fun characters(ch: CharArray, start: Int, length: Int) {
    }
    
    // 完成解析节点时调用
    override fun endElement(uri: String, localName: String, qName: String) {
    }

    // 完成解析时调用
    override fun endDocument() {
    }
}
```

解析实例：

```kotlin
class ContentHandler : DefaultHandler() {

    private var nodeName = ""

    private lateinit var id: StringBuilder

    private lateinit var name: StringBuilder

    private lateinit var version: StringBuilder

    override fun startDocument() {
        id = StringBuilder()
        name = StringBuilder()
        version = StringBuilder()
    }

    override fun startElement(uri: String, localName: String, qName: String, attributes: Attributes) {
        // 记录当前节点名
        nodeName = localName
        Log.d("ContentHandler", "uri is $uri")
        Log.d("ContentHandler", "localName is $localName")
        Log.d("ContentHandler", "qName is $qName")
        Log.d("ContentHandler", "attributes is $attributes")
    }

    override fun characters(ch: CharArray, start: Int, length: Int) {
        // 根据当前的节点名判断将内容添加到哪一个StringBuilder对象中
        when (nodeName) {
            "id" -> id.append(ch, start, length)
            "name" -> name.append(ch, start, length)
            "version" -> version.append(ch, start, length)
        }
    }

    override fun endElement(uri: String, localName: String, qName: String) {
        if ("app" == localName) {
            Log.d("ContentHandler", "id is ${id.toString().trim()}")
            Log.d("ContentHandler", "name is ${name.toString().trim()}")
            Log.d("ContentHandler", "version is ${version.toString().trim()}")
            // 最后要将StringBuilder清空掉
            id.setLength(0)
            name.setLength(0)
            version.setLength(0)
        }
    }

    override fun endDocument() {
    }
}
```

```kotlin
private fun parseXMLWithSAX(xmlData: String) {
    try {
        val factory = SAXParserFactory.newInstance()
        val xmlReader = factory.newSAXParser().getXMLReader()
        val handler = ContentHandler()
        // 将ContentHandler的实例设置到XMLReader中
        xmlReader.contentHandler = handler
        // 开始执行解析
        xmlReader.parse(InputSource(StringReader(xmlData)))
    } catch (e: Exception) {
        e.printStackTrace()
    }
}
```

#### 11.4 解析JSON格式数据

JSON格式数据与XML相比，体积更小，但是语义性较差，不如XML直观。

###### 使用JSONObject

```kotlin
private fun parseJSONWithJSONObject(jsonData: String) {
    try {
        // 需要根据JSON格式来确实解析后的对象
        val jsonArray = JSONArray(jsonData)
        for (i in 0 until jsonArray.length()) {
            val jsonObject = jsonArray.getJSONObject(i)
            val id = jsonObject.getString("id")
            val name = jsonObject.getString("name")
            val version = jsonObject.getString("version")
            Log.d("MainActivity", "id is $id")
            Log.d("MainActivity", "name is $name")
            Log.d("MainActivity", "version is $version")
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}
```

###### 使用GSON

定义JSON类

```kotlin
class App(val id: String, val name: String, val version: String)
```

定义解析类

```kotlin
private fun parseJSONWithGSON(jsonData: String) {
    val gson = Gson()
    val typeOf = object : TypeToken<List<App>>() {}.type
    val appList = gson.fromJson<List<App>>(jsonData, typeOf)
    for (app in appList) {
        Log.d("MainActivity", "id is ${app.id}")
        Log.d("MainActivity", "name is ${app.name}")
        Log.d("MainActivity", "version is ${app.version}")
    }
}
```

#### 11.5 网络请求回调的实现方式

###### HttpURLConnection

```kotlin
// 定义一个监听接口
interface HttpCallbackListener {
    // 服务器成功响应
    fun onFinish(response: String)
    // 出现错误
    fun onError(e: Exception)
}
```

```kotlin
// 网络请求方法中完成相应操作后调用方法
fun sendHttpRequest(address: String, listener: HttpCallbackListener) {
    thread {
        var connection: HttpURLConnection? = null
        try {
            val response = StringBuilder()
            val url = URL(address)
            connection = url.openConnection() as HttpURLConnection
            connection.connectTimeout = 8000
            connection.readTimeout = 8000

            val input = connection.inputStream
            val reader = BufferedReader(InputStreamReader(input))
            reader.use {
                reader.forEachLine {
                    response.append(it)
                }
            }
            // 回调onFinish()方法
            listener.onFinish(response.toString())
        } catch (e: Exception) {
            e.printStackTrace()
            // 回调onError()方法
            listener.onError(e)
        } finally {
            connection?.disconnect()
        }
    }
}
// 调用方法
HttpUtil.sendHttpRequest(address, object : HttpCallbackListener {
    override fun onFinish(response: String) {
        // 处理服务器返回的具体内容
    }

    override fun onError(e: Exception) {
        // 处理异常情况
    }
})
```

###### OkHttp

```kotlin
// OkHttp自带回调
fun sendOkHttpRequest(address: String, callback: okhttp3.Callback) {
    val client = OkHttpClient()
    val requestGet = Request.Builder()
        .url(address)
        .build()
    client.newCall(requestGet).enqueue(callback)
}
// 调用方法
HttpUtil.sendOkHttpRequest(address, object : Callback {
    override fun onFailure(call: Call, e: IOException) {
        // 处理异常情况
    }

    override fun onResponse(call: Call, response: Response) {
        // 得到服务器返回的具体内容
        val responseData = response.body?.string()
    }
})
```

上述方法中，接口回调依然是在子线程当中，不能进行UI操作。

#### 11.6 最好用的网络库：Retrofit

基本设计思想：

- 配置根路径，随后添加相对路径即可
- 对接口进行归类
- 不需要关心网络通信的细节

###### 基本用法

- 创建对象类

```kotlin
// Retrofit会将服务器返回的数据自动解析成对象 需要指定类
class App(val id: String, val name: String, val version: String)
```

- 创建接口类

```kotlin
// 命名习惯 以功能种类名开头(App)，以Service结尾
interface AppService {
	
    // GET注解 表明调用时发送GET请求 后接传入的参数 相对路径
    // 返回类型需声明为Call类型，且泛型内指定需要解析成什么对象(List<App>)
    @GET("get_data.json")
    fun getAppData(): Call<List<App>>

}
```

- 发起请求并处理返回数据

```kotlin
val retrofit = Retrofit.Builder()
    .baseUrl("http://10.0.2.2/")
	// 指定Retrofit在解析数据库时所使用的转换库
    .addConverterFactory(GsonConverterFactory.create())
    .build()
// 创建AppService接口的动态代理对象
val appService = retrofit.create(AppService::class.java)
// enqueue开始网络请求，并将请求结果回调至Callback中
appService.getAppData().enqueue(object : Callback<List<App>> {

    override fun onFailure(call: Call<List<App>>, t: Throwable) {
        // 处理请求失败逻辑
    }

    override fun onResponse(call: Call<List<App>>, response: Response<List<App>>) {
        // 处理请求成功逻辑
		val responseData = response.body()
    }
})
```

###### 处理较复杂的接口地址类型

HTTP常用请求类型：

`GET` ：用于向服务器请求数据

`POST` ：用于向服务器提交数据

`PUT`  、`PATCH` ：用于修改服务器数据

 `DELETE` ：用于删除服务器数据

```kotlin
interface ExampleService {

	// 接口地址的参数 
    // GET类型请求 "http://example.com/<page>/get_data.json"
    // 用{}添加占位符
	@GET("{page}/get_data.json")
	fun getData(@Path("page") page: Int): Call<App>
    
    // 接口地址后添加参数 
    // GET类型请求 "http://example.com/get_data.json?u=<user>&t=<token>"
    @GET("get_data.json")
    fun getData1(@Query("user") user: String, @Query("token") token: String): Call<App>

    // DELETE类型请求
    @DELETE("data/{id}")
    fun deleteData(@Path("id") id: String): Call<ResponseBody>

    // POST类型请求
    // Retrofit会将App对象转换成JSON格式的文本，并放到HTTP请求的body部分
    @POST("data/create")
    fun createData(@Body data: App): Call<ResponseBody>
    
    // 静态添加Header
    @Headers("User-Agent: okhttp", "Cache-Control: max-age=0")
    @GET("get_data.json")
    fun getData2(): Call<App>

    // 动态添加Header 使用@Header注解
    @GET("get_data.json")
    fun getData3(@Header("User-Agent") userAgent: String, @Header("Cache-Control") cacheControl: String): Call<Data>
}
```

###### Retrofit构建器的最佳写法

```kotlin
// 单例模式
object ServiceCreator {

    private const val BASE_URL = "http://10.0.2.2/"

    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    fun <T> create(serviceClass: Class<T>): T = retrofit.create(serviceClass)

    inline fun <reified T> create(): T = create(T::class.java)
}

// 调用方法
val appService = ServiceCreator.create(AppService::class.java)
// 或者
val appService = ServiceCreator.create<AppService>()
```

#### 11.7 Kotlin课堂：使用协程编写高效的并发程序

###### 基本用法

```kotlin
fun main() {
    // GlobalScope.launch创建的是顶层协程，协程会随着程序结束而结束
    GlobalScope.launch { 
    	println("codes run in Coroutine Scope")
        delay(1500)
        println("codes run in Coroutine Scope finished")
	}
    // 让主线程阻塞1秒钟
    Thread.sleep(1000)
}
```

`GlobalScope.launch` 函数会创建一个协程的作用域。创建的是**顶层协程**，协程会随着程序结束而结束。不建议使用，管理成本相对较高。

`delay()` 函数是一个非阻塞式的挂起函数，它只会挂起当前协程，并不会影响其他协程的运行。只能在协程的作用域或者其他挂起函数中调用。

`Thread.sleep()` 方法会阻塞当前的线程，因此在该线程下的所有协程都会被阻塞。

`runBlocking` 函数同样会创建一个协程的作用域，可以保证在协程作用域内的所有代码和子协程在全部执行完之前一直阻塞当前**线程**。通常只应该在测试环境中使用，在**正式环境**中使用容易产生一些性能上的问题。

`launch` 函数只能在在协程的作用域中调用，用于在当前协程的作用域下创建**子协程**。子协程的特点是如果外层作用域的协程结束了，该作用域下的所有子协程也会一同结束。

```kotlin
fun main() {
    val start = System.currentTimeMillis()
    runBlocking {
        repeat(1000000) {
            launch {
                println(".")
            }
        }
    }
    val end = System.currentTimeMillis()
    println(end - start)
}
// 	------  输出结果  ------
//	.
//	.
//	.
//	.
//	.
//	3137
//	
//	Process finished with exit code 0
// 1,000,000个协程 只花费3137毫秒 与线程相比是否轻量
```

关键字 **`suspend`** 可以将任意函数声明成挂起函数，挂起函数之间可以相互调用。但是不提供协程作用域，不能调用 `launch` 等

```kotlin
suspend fun printDot() {
    println(".")
    // delay()函数只能在协程作用域或者挂起函数中调用
    delay(1000)
}
```

 `coroutineScope` 函数是一个挂起函数，特点是会继承外部的协程作用域并创建一个子作用域 ，同时可以保证其作用域内所有代码和子协程在全部执行完之前会一直阻塞当前**协程**。

```kotlin
suspend fun printDot()  = coroutineScope { 
    launch { 
        println(".")
        delay(1000)
    }
}
```

```kotlin
fun main() {
	runBlocking {
        coroutineScope {
            launch {
                for (i in 1..3) {
                    println(i)
                    delay(1000)
                }
            }
        }
        println("coroutineScope finished")
    }
    println("runBlocking finished")
}
// 	------  输出结果  ------
// 	1
// 	2
// 	3
// 	coroutineScope finished
// 	runBlocking finished
// 	
// 	Process finished with exit code 0
```

###### 更多的作用域构建器

取消协程

```kotlin
// launch函数会返回一个Job对象 可以用于取消协程
val job = Job()
val scope = CoroutineScope(job)
scope.launch {
    // do something
}
// 取消scope协程及其所有子协程 不需要一个个取消
job.cancel()
```

 `CoroutineScope()`函数会返回一个CoroutineScope对象，传入的Job对象(job)会与获取到的CoroutineScope对象(scope)关联起来。随后使用scope.launch创建的子协程都会被关联到job的作用域下。因此要取消协程，只需要执行一次cancel()即可，便于管理。

async()函数

async函数必须在协程作用域中才能调用，用于创建一个新的子协程并返回一个Deferred对象，可以调用Deferred对象的await()方法获取async函数代码块**最后一行**的执行结果。

```kotlin
fun main() {

    runBlocking {
        val result = async {
            5 + 5
        }.await()
        println(result)
    }
}
```

async函数代码块中的代码在调用async函数之后会**立刻**开始执行。当调用await()方法时，如果代码块中的代码还没执行完，那么await()方法会将当前**协程**阻塞，直到获得async函数的执行结果。

```kotlin
fun main() {
    runBlocking {
        val start = System.currentTimeMillis()
        // 代码块中的代码立即执行
        val deferred1 = async {
            delay(1000)
            5 + 5
        }
        // 代码块中的代码立即执行 未被阻塞
        val deferred2 = async {
            delay(1000)
            4 + 6
        }
        // 阻塞 直到deferred1与deferred2获取到结果
        println("result is ${deferred1.await() + deferred2.await()}.")
        val end = System.currentTimeMillis()
        println("cost ${end - start} milliseconds.")
    }
}
// 	------  输出结果  ------
// 	result is 20.
// 	cost 1015 milliseconds.
// 	
// 	Process finished with exit code 0
```

withContext()函数

```kotlin
fun main() {
	runBlocking {
        val result = withContext(Dispatchers.Default) {
            5 + 5
        }
        println(result)
    }
    
    runBlocking { 
        val result = async { 
            5 + 5
        }.await()
        println(result)
    }
}
```

两个代码块中的内容大致相等，withContext约等于async的简约版。

调用withContext()函数后，会立即执行代码块中的代码，并阻塞当前协程，直到代码块中的代码全部执行完。随后，将最后一行代码的执行结果返回。

withContext()函数使用必须传入线程参数。

线程参数：

- Dispatchers.Default  默认低并发的线程策略，适于计算密集型任务
- Dispatchers.IO  较高并发的线程策略 适用于任务大多数时间都是处于阻塞和等待的
- Dispatchers.Main  不会开启子线程，在Android主线程中执行代码，只能在Android项目中使用

###### 使用协程简化回调的写法

`suspendCoroutine` 函数必须在协程作用域或者挂起函数中才能调用，接收一个Lambda表达式参数，主要作用是将当前协程立即挂起，然后在一个普通线程中执行Lambda表达式中的代码。

Lambda表达式的参数列表会传入一个Continuation参数，调用Continuation的resume()方法或者resumeWithException()方法可以让协程恢复执行。

```kotlin
suspend fun getAppData() {
    try {
        val appList = ServiceCreator.create<AppService>().getAppData()
            .await()
        println(appList)
        // 对服务器响应的数据进行处理
    } catch (e: Exception) {
        // 对异常情况进行处理
        e.printStackTrace()
    }
}

// 为Call<T>添加一个await()扩展函数
// 所有返回值类型为Call类型的Retrofit网络请求都可以调用该方法
suspend fun <T> Call<T>.await(): T {
    return suspendCoroutine { continuation ->
        enqueue(object : Callback<T> {
            override fun onResponse(call: Call<T>, response: Response<T>) {
                val body = response.body()
                if (body != null) continuation.resume(body)
                else continuation.resumeWithException(RuntimeException("response body is null"))
            }

            override fun onFailure(call: Call<T>, t: Throwable) {
                continuation.resumeWithException(t)
            }
        })
    }
}
```

异常可以一层层向上抛出，直到被某一层处理完。



## 第12章 最佳的UI体验，Material Design实践

#### 12.1 什么是Material Design

Google的，界面设计语言，好看。

#### 12.2 Toolbar

去掉ActionBar

修改AndroidManifest.xml中 `android:theme="@style/AppTheme"` 的 `AppTheme` 的parent主题

将 `"Theme.AppCompat.Light.DarkActionBar"` 修改成 `"Theme.AppCompat.Light.NoActionBar"` (浅色主题)或 `"Theme.AppCompat.NoActionBar"` (深色主题)

布局文件

XML中 `xmlns:android` 指定命名空间，使得XML中可以使用 `android:id` 、 `android:layout_width` 等写法。

XML中 `xmlns:app` 指定命名空间，使得XML中可以使用 `app:atribute` 的写法。

显示Toolbar

- XML中添加
- 代码中添加 `setSupportActionBar(toolbar)`

修改标题

XML中给Activity添加 `android:label="Fruits"` 标签即可

添加Menu

- 添加Menu的对应XML文件
- 配置对应Item
- 添加相关属性
- 代码中添加两个方法即可 `onCreateOptionsMenu` 和 `onOptionsItemSelected`

#### 12.3 滑动菜单

DrawerLayout

